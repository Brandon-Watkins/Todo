{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/brandon/Desktop/ReactProjects/Proj2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.separateMessageFromStack = exports.formatResultsErrors = exports.formatStackTrace = exports.getTopFrame = exports.getStackTraceLines = exports.formatExecError = void 0;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar _micromatch = _interopRequireDefault(require('micromatch'));\n\nvar _slash = _interopRequireDefault(require('slash'));\n\nvar _codeFrame = require('@babel/code-frame');\n\nvar _stackUtils = _interopRequireDefault(require('stack-utils'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestReadFile = global[Symbol.for('jest-native-read-file')] || fs.readFileSync; // stack utils tries to create pretty stack by making paths relative.\n\nconst stackUtils = new _stackUtils.default({\n  cwd: 'something which does not exist'\n});\nlet nodeInternals = [];\n\ntry {\n  nodeInternals = _stackUtils.default.nodeInternals();\n} catch (e) {// `StackUtils.nodeInternals()` fails in browsers. We don't need to remove\n  // node internals in the browser though, so no issue.\n}\n\nconst PATH_NODE_MODULES = \"\".concat(path.sep, \"node_modules\").concat(path.sep);\nconst PATH_JEST_PACKAGES = \"\".concat(path.sep, \"jest\").concat(path.sep, \"packages\").concat(path.sep); // filter for noisy stack trace lines\n\nconst JASMINE_IGNORE = /^\\s+at(?:(?:.jasmine\\-)|\\s+jasmine\\.buildExpectationResult)/;\nconst JEST_INTERNALS_IGNORE = /^\\s+at.*?jest(-.*?)?(\\/|\\\\)(build|node_modules|packages)(\\/|\\\\)/;\nconst ANONYMOUS_FN_IGNORE = /^\\s+at <anonymous>.*$/;\nconst ANONYMOUS_PROMISE_IGNORE = /^\\s+at (new )?Promise \\(<anonymous>\\).*$/;\nconst ANONYMOUS_GENERATOR_IGNORE = /^\\s+at Generator.next \\(<anonymous>\\).*$/;\nconst NATIVE_NEXT_IGNORE = /^\\s+at next \\(native\\).*$/;\nconst TITLE_INDENT = '  ';\nconst MESSAGE_INDENT = '    ';\nconst STACK_INDENT = '      ';\nconst ANCESTRY_SEPARATOR = ' \\u203A ';\n\nconst TITLE_BULLET = _chalk.default.bold('\\u25cf ');\n\nconst STACK_TRACE_COLOR = _chalk.default.dim;\nconst STACK_PATH_REGEXP = /\\s*at.*\\(?(\\:\\d*\\:\\d*|native)\\)?/;\nconst EXEC_ERROR_MESSAGE = 'Test suite failed to run';\nconst NOT_EMPTY_LINE_REGEXP = /^(?!$)/gm;\n\nconst indentAllLines = (lines, indent) => lines.replace(NOT_EMPTY_LINE_REGEXP, indent);\n\nconst trim = string => (string || '').trim(); // Some errors contain not only line numbers in stack traces\n// e.g. SyntaxErrors can contain snippets of code, and we don't\n// want to trim those, because they may have pointers to the column/character\n// which will get misaligned.\n\n\nconst trimPaths = string => string.match(STACK_PATH_REGEXP) ? trim(string) : string;\n\nconst getRenderedCallsite = (fileContent, line, column) => {\n  let renderedCallsite = (0, _codeFrame.codeFrameColumns)(fileContent, {\n    start: {\n      column,\n      line\n    }\n  }, {\n    highlightCode: true\n  });\n  renderedCallsite = indentAllLines(renderedCallsite, MESSAGE_INDENT);\n  renderedCallsite = \"\\n\".concat(renderedCallsite, \"\\n\");\n  return renderedCallsite;\n};\n\nconst blankStringRegexp = /^\\s*$/;\n\nfunction checkForCommonEnvironmentErrors(error) {\n  if (error.includes('ReferenceError: document is not defined') || error.includes('ReferenceError: window is not defined') || error.includes('ReferenceError: navigator is not defined')) {\n    return warnAboutWrongTestEnvironment(error, 'jsdom');\n  } else if (error.includes('.unref is not a function')) {\n    return warnAboutWrongTestEnvironment(error, 'node');\n  }\n\n  return error;\n}\n\nfunction warnAboutWrongTestEnvironment(error, env) {\n  return _chalk.default.bold.red(\"The error below may be caused by using the wrong test environment, see \".concat(_chalk.default.dim.underline('https://jestjs.io/docs/en/configuration#testenvironment-string'), \".\\nConsider using the \\\"\").concat(env, \"\\\" test environment.\\n\\n\")) + error;\n} // ExecError is an error thrown outside of the test suite (not inside an `it` or\n// `before/after each` hooks). If it's thrown, none of the tests in the file\n// are executed.\n\n\nconst formatExecError = (error, config, options, testPath, reuseMessage) => {\n  if (!error || typeof error === 'number') {\n    error = new Error(\"Expected an Error, but \\\"\".concat(String(error), \"\\\" was thrown\"));\n    error.stack = '';\n  }\n\n  let message, stack;\n\n  if (typeof error === 'string' || !error) {\n    error || (error = 'EMPTY ERROR');\n    message = '';\n    stack = error;\n  } else {\n    message = error.message;\n    stack = error.stack;\n  }\n\n  const separated = separateMessageFromStack(stack || '');\n  stack = separated.stack;\n\n  if (separated.message.includes(trim(message))) {\n    // Often stack trace already contains the duplicate of the message\n    message = separated.message;\n  }\n\n  message = checkForCommonEnvironmentErrors(message);\n  message = indentAllLines(message, MESSAGE_INDENT);\n  stack = stack && !options.noStackTrace ? '\\n' + formatStackTrace(stack, config, options, testPath) : '';\n\n  if (blankStringRegexp.test(message) && blankStringRegexp.test(stack)) {\n    // this can happen if an empty object is thrown.\n    message = MESSAGE_INDENT + 'Error: No message was provided';\n  }\n\n  let messageToUse;\n\n  if (reuseMessage) {\n    messageToUse = \" \".concat(message.trim());\n  } else {\n    messageToUse = \"\".concat(EXEC_ERROR_MESSAGE, \"\\n\\n\").concat(message);\n  }\n\n  return TITLE_INDENT + TITLE_BULLET + messageToUse + stack + '\\n';\n};\n\nexports.formatExecError = formatExecError;\n\nconst removeInternalStackEntries = (lines, options) => {\n  let pathCounter = 0;\n  return lines.filter(line => {\n    if (ANONYMOUS_FN_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_PROMISE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (NATIVE_NEXT_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (nodeInternals.some(internal => internal.test(line))) {\n      return false;\n    }\n\n    if (!STACK_PATH_REGEXP.test(line)) {\n      return true;\n    }\n\n    if (JASMINE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (++pathCounter === 1) {\n      return true; // always keep the first line even if it's from Jest\n    }\n\n    if (options.noStackTrace) {\n      return false;\n    }\n\n    if (JEST_INTERNALS_IGNORE.test(line)) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\nconst formatPaths = (config, relativeTestPath, line) => {\n  // Extract the file path from the trace line.\n  const match = line.match(/(^\\s*at .*?\\(?)([^()]+)(:[0-9]+:[0-9]+\\)?.*$)/);\n\n  if (!match) {\n    return line;\n  }\n\n  let filePath = (0, _slash.default)(path.relative(config.rootDir, match[2])); // highlight paths from the current test file\n\n  if (config.testMatch && config.testMatch.length && (0, _micromatch.default)([filePath], config.testMatch).length > 0 || filePath === relativeTestPath) {\n    filePath = _chalk.default.reset.cyan(filePath);\n  }\n\n  return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);\n};\n\nconst getStackTraceLines = (stack, options = {\n  noCodeFrame: false,\n  noStackTrace: false\n}) => removeInternalStackEntries(stack.split(/\\n/), options);\n\nexports.getStackTraceLines = getStackTraceLines;\n\nconst getTopFrame = lines => {\n  var _iterator = _createForOfIteratorHelper(lines),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      const line = _step.value;\n\n      if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {\n        continue;\n      }\n\n      const parsedFrame = stackUtils.parseLine(line.trim());\n\n      if (parsedFrame && parsedFrame.file) {\n        return parsedFrame;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return null;\n};\n\nexports.getTopFrame = getTopFrame;\n\nconst formatStackTrace = (stack, config, options, testPath) => {\n  const lines = getStackTraceLines(stack, options);\n  let renderedCallsite = '';\n  const relativeTestPath = testPath ? (0, _slash.default)(path.relative(config.rootDir, testPath)) : null;\n\n  if (!options.noStackTrace && !options.noCodeFrame) {\n    const topFrame = getTopFrame(lines);\n\n    if (topFrame) {\n      const column = topFrame.column,\n            filename = topFrame.file,\n            line = topFrame.line;\n\n      if (line && filename && path.isAbsolute(filename)) {\n        let fileContent;\n\n        try {\n          // TODO: check & read HasteFS instead of reading the filesystem:\n          // see: https://github.com/facebook/jest/pull/5405#discussion_r164281696\n          fileContent = jestReadFile(filename, 'utf8');\n          renderedCallsite = getRenderedCallsite(fileContent, line, column);\n        } catch (e) {// the file does not exist or is inaccessible, we ignore\n        }\n      }\n    }\n  }\n\n  const stacktrace = lines.filter(Boolean).map(line => STACK_INDENT + formatPaths(config, relativeTestPath, trimPaths(line))).join('\\n');\n  return renderedCallsite ? \"\".concat(renderedCallsite, \"\\n\").concat(stacktrace) : \"\\n\".concat(stacktrace);\n};\n\nexports.formatStackTrace = formatStackTrace;\n\nconst formatResultsErrors = (testResults, config, options, testPath) => {\n  const failedResults = testResults.reduce((errors, result) => {\n    result.failureMessages.map(checkForCommonEnvironmentErrors).forEach(content => errors.push({\n      content,\n      result\n    }));\n    return errors;\n  }, []);\n\n  if (!failedResults.length) {\n    return null;\n  }\n\n  return failedResults.map(({\n    result,\n    content\n  }) => {\n    let _separateMessageFromS = separateMessageFromStack(content),\n        message = _separateMessageFromS.message,\n        stack = _separateMessageFromS.stack;\n\n    stack = options.noStackTrace ? '' : STACK_TRACE_COLOR(formatStackTrace(stack, config, options, testPath)) + '\\n';\n    message = indentAllLines(message, MESSAGE_INDENT);\n    const title = _chalk.default.bold.red(TITLE_INDENT + TITLE_BULLET + result.ancestorTitles.join(ANCESTRY_SEPARATOR) + (result.ancestorTitles.length ? ANCESTRY_SEPARATOR : '') + result.title) + '\\n';\n    return title + '\\n' + message + '\\n' + stack;\n  }).join('\\n');\n};\n\nexports.formatResultsErrors = formatResultsErrors;\nconst errorRegexp = /^Error:?\\s*$/;\n\nconst removeBlankErrorLine = str => str.split('\\n') // Lines saying just `Error:` are useless\n.filter(line => !errorRegexp.test(line)).join('\\n').trimRight(); // jasmine and worker farm sometimes don't give us access to the actual\n// Error object, so we have to regexp out the message from the stack string\n// to format it.\n\n\nconst separateMessageFromStack = content => {\n  if (!content) {\n    return {\n      message: '',\n      stack: ''\n    };\n  } // All lines up to what looks like a stack -- or if nothing looks like a stack\n  // (maybe it's a code frame instead), just the first non-empty line.\n  // If the error is a plain \"Error:\" instead of a SyntaxError or TypeError we\n  // remove the prefix from the message because it is generally not useful.\n\n\n  const messageMatch = content.match(/^(?:Error: )?([\\s\\S]*?(?=\\n\\s*at\\s.*:\\d*:\\d*)|\\s*.*)([\\s\\S]*)$/);\n\n  if (!messageMatch) {\n    // For typescript\n    throw new Error('If you hit this error, the regex above is buggy.');\n  }\n\n  const message = removeBlankErrorLine(messageMatch[1]);\n  const stack = removeBlankErrorLine(messageMatch[2]);\n  return {\n    message,\n    stack\n  };\n};\n\nexports.separateMessageFromStack = separateMessageFromStack;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/brandon/Desktop/ReactProjects/Proj2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _objectSpread = require(\"/Users/brandon/Desktop/ReactProjects/Proj2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nconst escapeStringRegexp = require('escape-string-regexp');\n\nconst natives = [].concat(require('module').builtinModules, 'bootstrap_node', 'node').map(n => new RegExp(\"(?:\\\\(\".concat(n, \"\\\\.js:\\\\d+:\\\\d+\\\\)$|^\\\\s*at \").concat(n, \"\\\\.js:\\\\d+:\\\\d+$)\")));\nnatives.push(/\\(internal\\/[^:]+:\\d+:\\d+\\)$/, /\\s*at internal\\/[^:]+:\\d+:\\d+$/, /\\/\\.node-spawn-wrap-\\w+-\\w+\\/node:\\d+:\\d+\\)?$/);\n\nclass StackUtils {\n  constructor(opts) {\n    opts = _objectSpread({\n      ignoredPackages: []\n    }, opts);\n\n    if ('internals' in opts === false) {\n      opts.internals = StackUtils.nodeInternals();\n    }\n\n    if ('cwd' in opts === false) {\n      opts.cwd = process.cwd();\n    }\n\n    this._cwd = opts.cwd.replace(/\\\\/g, '/');\n    this._internals = [].concat(opts.internals, ignoredPackagesRegExp(opts.ignoredPackages));\n    this._wrapCallSite = opts.wrapCallSite || false;\n  }\n\n  static nodeInternals() {\n    return [...natives];\n  }\n\n  clean(stack, indent = 0) {\n    indent = ' '.repeat(indent);\n\n    if (!Array.isArray(stack)) {\n      stack = stack.split('\\n');\n    }\n\n    if (!/^\\s*at /.test(stack[0]) && /^\\s*at /.test(stack[1])) {\n      stack = stack.slice(1);\n    }\n\n    let outdent = false;\n    let lastNonAtLine = null;\n    const result = [];\n    stack.forEach(st => {\n      st = st.replace(/\\\\/g, '/');\n\n      if (this._internals.some(internal => internal.test(st))) {\n        return;\n      }\n\n      const isAtLine = /^\\s*at /.test(st);\n\n      if (outdent) {\n        st = st.trimEnd().replace(/^(\\s+)at /, '$1');\n      } else {\n        st = st.trim();\n\n        if (isAtLine) {\n          st = st.slice(3);\n        }\n      }\n\n      st = st.replace(\"\".concat(this._cwd, \"/\"), '');\n\n      if (st) {\n        if (isAtLine) {\n          if (lastNonAtLine) {\n            result.push(lastNonAtLine);\n            lastNonAtLine = null;\n          }\n\n          result.push(st);\n        } else {\n          outdent = true;\n          lastNonAtLine = st;\n        }\n      }\n    });\n    return result.map(line => \"\".concat(indent).concat(line, \"\\n\")).join('');\n  }\n\n  captureString(limit, fn = this.captureString) {\n    if (typeof limit === 'function') {\n      fn = limit;\n      limit = Infinity;\n    }\n\n    const stackTraceLimit = Error.stackTraceLimit;\n\n    if (limit) {\n      Error.stackTraceLimit = limit;\n    }\n\n    const obj = {};\n    Error.captureStackTrace(obj, fn);\n    const stack = obj.stack;\n    Error.stackTraceLimit = stackTraceLimit;\n    return this.clean(stack);\n  }\n\n  capture(limit, fn = this.capture) {\n    if (typeof limit === 'function') {\n      fn = limit;\n      limit = Infinity;\n    }\n\n    const prepareStackTrace = Error.prepareStackTrace,\n          stackTraceLimit = Error.stackTraceLimit;\n\n    Error.prepareStackTrace = (obj, site) => {\n      if (this._wrapCallSite) {\n        return site.map(this._wrapCallSite);\n      }\n\n      return site;\n    };\n\n    if (limit) {\n      Error.stackTraceLimit = limit;\n    }\n\n    const obj = {};\n    Error.captureStackTrace(obj, fn);\n    const stack = obj.stack;\n    Object.assign(Error, {\n      prepareStackTrace,\n      stackTraceLimit\n    });\n    return stack;\n  }\n\n  at(fn = this.at) {\n    const _this$capture = this.capture(1, fn),\n          _this$capture2 = _slicedToArray(_this$capture, 1),\n          site = _this$capture2[0];\n\n    if (!site) {\n      return {};\n    }\n\n    const res = {\n      line: site.getLineNumber(),\n      column: site.getColumnNumber()\n    };\n    setFile(res, site.getFileName(), this._cwd);\n\n    if (site.isConstructor()) {\n      res.constructor = true;\n    }\n\n    if (site.isEval()) {\n      res.evalOrigin = site.getEvalOrigin();\n    } // Node v10 stopped with the isNative() on callsites, apparently\n\n    /* istanbul ignore next */\n\n\n    if (site.isNative()) {\n      res.native = true;\n    }\n\n    let typename;\n\n    try {\n      typename = site.getTypeName();\n    } catch (_) {}\n\n    if (typename && typename !== 'Object' && typename !== '[object Object]') {\n      res.type = typename;\n    }\n\n    const fname = site.getFunctionName();\n\n    if (fname) {\n      res.function = fname;\n    }\n\n    const meth = site.getMethodName();\n\n    if (meth && fname !== meth) {\n      res.method = meth;\n    }\n\n    return res;\n  }\n\n  parseLine(line) {\n    const match = line && line.match(re);\n\n    if (!match) {\n      return null;\n    }\n\n    const ctor = match[1] === 'new';\n    let fname = match[2];\n    const evalOrigin = match[3];\n    const evalFile = match[4];\n    const evalLine = Number(match[5]);\n    const evalCol = Number(match[6]);\n    let file = match[7];\n    const lnum = match[8];\n    const col = match[9];\n    const native = match[10] === 'native';\n    const closeParen = match[11] === ')';\n    let method;\n    const res = {};\n\n    if (lnum) {\n      res.line = Number(lnum);\n    }\n\n    if (col) {\n      res.column = Number(col);\n    }\n\n    if (closeParen && file) {\n      // make sure parens are balanced\n      // if we have a file like \"asdf) [as foo] (xyz.js\", then odds are\n      // that the fname should be += \" (asdf) [as foo]\" and the file\n      // should be just \"xyz.js\"\n      // walk backwards from the end to find the last unbalanced (\n      let closes = 0;\n\n      for (let i = file.length - 1; i > 0; i--) {\n        if (file.charAt(i) === ')') {\n          closes++;\n        } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {\n          closes--;\n\n          if (closes === -1 && file.charAt(i - 1) === ' ') {\n            const before = file.slice(0, i - 1);\n            const after = file.slice(i + 1);\n            file = after;\n            fname += \" (\".concat(before);\n            break;\n          }\n        }\n      }\n    }\n\n    if (fname) {\n      const methodMatch = fname.match(methodRe);\n\n      if (methodMatch) {\n        fname = methodMatch[1];\n        method = methodMatch[2];\n      }\n    }\n\n    setFile(res, file, this._cwd);\n\n    if (ctor) {\n      res.constructor = true;\n    }\n\n    if (evalOrigin) {\n      res.evalOrigin = evalOrigin;\n      res.evalLine = evalLine;\n      res.evalColumn = evalCol;\n      res.evalFile = evalFile && evalFile.replace(/\\\\/g, '/');\n    }\n\n    if (native) {\n      res.native = true;\n    }\n\n    if (fname) {\n      res.function = fname;\n    }\n\n    if (method && fname !== method) {\n      res.method = method;\n    }\n\n    return res;\n  }\n\n}\n\nfunction setFile(result, filename, cwd) {\n  if (filename) {\n    filename = filename.replace(/\\\\/g, '/');\n\n    if (filename.startsWith(\"\".concat(cwd, \"/\"))) {\n      filename = filename.slice(cwd.length + 1);\n    }\n\n    result.file = filename;\n  }\n}\n\nfunction ignoredPackagesRegExp(ignoredPackages) {\n  if (ignoredPackages.length === 0) {\n    return [];\n  }\n\n  const packages = ignoredPackages.map(mod => escapeStringRegexp(mod));\n  return new RegExp(\"[/\\\\\\\\]node_modules[/\\\\\\\\](?:\".concat(packages.join('|'), \")[/\\\\\\\\][^:]+:\\\\d+:\\\\d+\"));\n}\n\nconst re = new RegExp('^' + // Sometimes we strip out the '    at' because it's noisy\n'(?:\\\\s*at )?' + // $1 = ctor if 'new'\n'(?:(new) )?' + // $2 = function name (can be literally anything)\n// May contain method at the end as [as xyz]\n'(?:(.*?) \\\\()?' + // (eval at <anonymous> (file.js:1:1),\n// $3 = eval origin\n// $4:$5:$6 are eval file/line/col, but not normally reported\n'(?:eval at ([^ ]+) \\\\((.+?):(\\\\d+):(\\\\d+)\\\\), )?' + // file:line:col\n// $7:$8:$9\n// $10 = 'native' if native\n'(?:(.+?):(\\\\d+):(\\\\d+)|(native))' + // maybe close the paren, then end\n// if $11 is ), then we only allow balanced parens in the filename\n// any imbalance is placed on the fname.  This is a heuristic, and\n// bound to be incorrect in some edge cases.  The bet is that\n// having weird characters in method names is more common than\n// having weird characters in filenames, which seems reasonable.\n'(\\\\)?)$');\nconst methodRe = /^(.*?) \\[as (.*?)\\]$/;\nmodule.exports = StackUtils;","map":null,"metadata":{},"sourceType":"script"}
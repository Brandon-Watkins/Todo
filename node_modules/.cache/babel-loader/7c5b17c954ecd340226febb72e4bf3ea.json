{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _jestGetType = _interopRequireDefault(require('jest-get-type'));\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _print = require('./print');\n\nvar _utils = require('./utils');\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// Omit colon and one or more spaces, so can call getLabelPrinter.\n\n\nconst EXPECTED_LABEL = 'Expected';\nconst RECEIVED_LABEL = 'Received';\nconst EXPECTED_VALUE_LABEL = 'Expected value';\nconst RECEIVED_VALUE_LABEL = 'Received value'; // The optional property of matcher context is true if undefined.\n\nconst isExpand = expand => expand !== false;\n\nconst toStrictEqualTesters = [_utils.iterableEquality, _utils.typeEquality, _utils.sparseArrayEquality];\nconst matchers = {\n  toBe(received, expected) {\n    const matcherName = 'toBe';\n    const options = {\n      comment: 'Object.is equality',\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    const pass = Object.is(received, expected);\n    const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"Expected: not \".concat((0, _jestMatcherUtils.printExpected)(expected)) : () => {\n      const expectedType = (0, _jestGetType.default)(expected);\n      let deepEqualityName = null;\n\n      if (expectedType !== 'map' && expectedType !== 'set') {\n        // If deep equality passes when referential identity fails,\n        // but exclude map and set until review of their equality logic.\n        if ((0, _jasmineUtils.equals)(received, expected, toStrictEqualTesters, true)) {\n          deepEqualityName = 'toStrictEqual';\n        } else if ((0, _jasmineUtils.equals)(received, expected, [_utils.iterableEquality])) {\n          deepEqualityName = 'toEqual';\n        }\n      }\n\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + (deepEqualityName !== null ? (0, _jestMatcherUtils.DIM_COLOR)(\"If it should pass with deep equality, replace \\\"\".concat(matcherName, \"\\\" with \\\"\").concat(deepEqualityName, \"\\\"\")) + '\\n\\n' : '') + (0, _jestMatcherUtils.printDiffOrStringify)(expected, received, EXPECTED_LABEL, RECEIVED_LABEL, isExpand(this.expand));\n    }; // Passing the actual and expected objects so that a custom reporter\n    // could access them, for example in order to display a custom visual diff,\n    // or create a different error message\n\n    return {\n      actual: received,\n      expected,\n      message,\n      name: matcherName,\n      pass\n    };\n  },\n\n  toBeCloseTo(received, expected, precision = 2) {\n    const matcherName = 'toBeCloseTo';\n    const secondArgument = arguments.length === 3 ? 'precision' : undefined;\n    const isNot = this.isNot;\n    const options = {\n      isNot,\n      promise: this.promise,\n      secondArgument,\n      secondArgumentColor: arg => arg\n    };\n\n    if (typeof expected !== 'number') {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), \"\".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('expected'), \" value must be a number\"), (0, _jestMatcherUtils.printWithType)('Expected', expected, _jestMatcherUtils.printExpected)));\n    }\n\n    if (typeof received !== 'number') {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), \" value must be a number\"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n    }\n\n    let pass = false;\n    let expectedDiff = 0;\n    let receivedDiff = 0;\n\n    if (received === Infinity && expected === Infinity) {\n      pass = true; // Infinity - Infinity is NaN\n    } else if (received === -Infinity && expected === -Infinity) {\n      pass = true; // -Infinity - -Infinity is NaN\n    } else {\n      expectedDiff = Math.pow(10, -precision) / 2;\n      receivedDiff = Math.abs(expected - received);\n      pass = receivedDiff < expectedDiff;\n    }\n\n    const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"Expected: not \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + (receivedDiff === 0 ? '' : \"Received:     \".concat((0, _jestMatcherUtils.printReceived)(received), \"\\n\") + '\\n' + (0, _print.printCloseTo)(receivedDiff, expectedDiff, precision, isNot)) : () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"Expected: \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"Received: \".concat((0, _jestMatcherUtils.printReceived)(received), \"\\n\") + '\\n' + (0, _print.printCloseTo)(receivedDiff, expectedDiff, precision, isNot);\n    return {\n      message,\n      pass\n    };\n  },\n\n  toBeDefined(received, expected) {\n    const matcherName = 'toBeDefined';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n    const pass = received !== void 0;\n\n    const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\\n\\n' + \"Received: \".concat((0, _jestMatcherUtils.printReceived)(received));\n\n    return {\n      message,\n      pass\n    };\n  },\n\n  toBeFalsy(received, expected) {\n    const matcherName = 'toBeFalsy';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n    const pass = !received;\n\n    const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\\n\\n' + \"Received: \".concat((0, _jestMatcherUtils.printReceived)(received));\n\n    return {\n      message,\n      pass\n    };\n  },\n\n  toBeGreaterThan(received, expected) {\n    const matcherName = 'toBeGreaterThan';\n    const isNot = this.isNot;\n    const options = {\n      isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNumbers)(received, expected, matcherName, options);\n    const pass = received > expected;\n\n    const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"Expected:\".concat(isNot ? ' not' : '', \" > \").concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"Received:\".concat(isNot ? '    ' : '', \"   \").concat((0, _jestMatcherUtils.printReceived)(received));\n\n    return {\n      message,\n      pass\n    };\n  },\n\n  toBeGreaterThanOrEqual(received, expected) {\n    const matcherName = 'toBeGreaterThanOrEqual';\n    const isNot = this.isNot;\n    const options = {\n      isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNumbers)(received, expected, matcherName, options);\n    const pass = received >= expected;\n\n    const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"Expected:\".concat(isNot ? ' not' : '', \" >= \").concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"Received:\".concat(isNot ? '    ' : '', \"    \").concat((0, _jestMatcherUtils.printReceived)(received));\n\n    return {\n      message,\n      pass\n    };\n  },\n\n  toBeInstanceOf(received, expected) {\n    const matcherName = 'toBeInstanceOf';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n\n    if (typeof expected !== 'function') {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), \"\".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('expected'), \" value must be a function\"), (0, _jestMatcherUtils.printWithType)('Expected', expected, _jestMatcherUtils.printExpected)));\n    }\n\n    const pass = received instanceof expected;\n    const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + (0, _print.printExpectedConstructorNameNot)('Expected constructor', expected) + (typeof received.constructor === 'function' && received.constructor !== expected ? (0, _print.printReceivedConstructorNameNot)('Received constructor', received.constructor, expected) : '') : () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + (0, _print.printExpectedConstructorName)('Expected constructor', expected) + (_jestGetType.default.isPrimitive(received) || Object.getPrototypeOf(received) === null ? \"\\nReceived value has no prototype\\nReceived value: \".concat((0, _jestMatcherUtils.printReceived)(received)) : typeof received.constructor !== 'function' ? \"\\nReceived value: \".concat((0, _jestMatcherUtils.printReceived)(received)) : (0, _print.printReceivedConstructorName)('Received constructor', received.constructor));\n    return {\n      message,\n      pass\n    };\n  },\n\n  toBeLessThan(received, expected) {\n    const matcherName = 'toBeLessThan';\n    const isNot = this.isNot;\n    const options = {\n      isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNumbers)(received, expected, matcherName, options);\n    const pass = received < expected;\n\n    const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"Expected:\".concat(isNot ? ' not' : '', \" < \").concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"Received:\".concat(isNot ? '    ' : '', \"   \").concat((0, _jestMatcherUtils.printReceived)(received));\n\n    return {\n      message,\n      pass\n    };\n  },\n\n  toBeLessThanOrEqual(received, expected) {\n    const matcherName = 'toBeLessThanOrEqual';\n    const isNot = this.isNot;\n    const options = {\n      isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNumbers)(received, expected, matcherName, options);\n    const pass = received <= expected;\n\n    const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"Expected:\".concat(isNot ? ' not' : '', \" <= \").concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"Received:\".concat(isNot ? '    ' : '', \"    \").concat((0, _jestMatcherUtils.printReceived)(received));\n\n    return {\n      message,\n      pass\n    };\n  },\n\n  toBeNaN(received, expected) {\n    const matcherName = 'toBeNaN';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n    const pass = Number.isNaN(received);\n\n    const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\\n\\n' + \"Received: \".concat((0, _jestMatcherUtils.printReceived)(received));\n\n    return {\n      message,\n      pass\n    };\n  },\n\n  toBeNull(received, expected) {\n    const matcherName = 'toBeNull';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n    const pass = received === null;\n\n    const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\\n\\n' + \"Received: \".concat((0, _jestMatcherUtils.printReceived)(received));\n\n    return {\n      message,\n      pass\n    };\n  },\n\n  toBeTruthy(received, expected) {\n    const matcherName = 'toBeTruthy';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n    const pass = !!received;\n\n    const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\\n\\n' + \"Received: \".concat((0, _jestMatcherUtils.printReceived)(received));\n\n    return {\n      message,\n      pass\n    };\n  },\n\n  toBeUndefined(received, expected) {\n    const matcherName = 'toBeUndefined';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n    const pass = received === void 0;\n\n    const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\\n\\n' + \"Received: \".concat((0, _jestMatcherUtils.printReceived)(received));\n\n    return {\n      message,\n      pass\n    };\n  },\n\n  toContain(received, expected) {\n    const matcherName = 'toContain';\n    const isNot = this.isNot;\n    const options = {\n      comment: 'indexOf',\n      isNot,\n      promise: this.promise\n    };\n\n    if (received == null) {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), \" value must not be null nor undefined\"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n    }\n\n    if (typeof received === 'string') {\n      const index = received.indexOf(String(expected));\n      const pass = index !== -1;\n\n      const message = () => {\n        const labelExpected = \"Expected \".concat(typeof expected === 'string' ? 'substring' : 'value');\n        const labelReceived = 'Received string';\n        const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceived);\n        return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"\".concat(printLabel(labelExpected)).concat(isNot ? 'not ' : '').concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"\".concat(printLabel(labelReceived)).concat(isNot ? '    ' : '').concat(isNot ? (0, _print.printReceivedStringContainExpectedSubstring)(received, index, String(expected).length) : (0, _jestMatcherUtils.printReceived)(received));\n      };\n\n      return {\n        message,\n        pass\n      };\n    }\n\n    const indexable = Array.from(received);\n    const index = indexable.indexOf(expected);\n    const pass = index !== -1;\n\n    const message = () => {\n      const labelExpected = 'Expected value';\n      const labelReceived = \"Received \".concat((0, _jestGetType.default)(received));\n      const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceived);\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"\".concat(printLabel(labelExpected)).concat(isNot ? 'not ' : '').concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"\".concat(printLabel(labelReceived)).concat(isNot ? '    ' : '').concat(isNot && Array.isArray(received) ? (0, _print.printReceivedArrayContainExpectedItem)(received, index) : (0, _jestMatcherUtils.printReceived)(received)) + (!isNot && indexable.findIndex(item => (0, _jasmineUtils.equals)(item, expected, [_utils.iterableEquality])) !== -1 ? \"\\n\\n\".concat(_jestMatcherUtils.SUGGEST_TO_CONTAIN_EQUAL) : '');\n    };\n\n    return {\n      message,\n      pass\n    };\n  },\n\n  toContainEqual(received, expected) {\n    const matcherName = 'toContainEqual';\n    const isNot = this.isNot;\n    const options = {\n      comment: 'deep equality',\n      isNot,\n      promise: this.promise\n    };\n\n    if (received == null) {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), \" value must not be null nor undefined\"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n    }\n\n    const index = Array.from(received).findIndex(item => (0, _jasmineUtils.equals)(item, expected, [_utils.iterableEquality]));\n    const pass = index !== -1;\n\n    const message = () => {\n      const labelExpected = 'Expected value';\n      const labelReceived = \"Received \".concat((0, _jestGetType.default)(received));\n      const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceived);\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"\".concat(printLabel(labelExpected)).concat(isNot ? 'not ' : '').concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"\".concat(printLabel(labelReceived)).concat(isNot ? '    ' : '').concat(isNot && Array.isArray(received) ? (0, _print.printReceivedArrayContainExpectedItem)(received, index) : (0, _jestMatcherUtils.printReceived)(received));\n    };\n\n    return {\n      message,\n      pass\n    };\n  },\n\n  toEqual(received, expected) {\n    const matcherName = 'toEqual';\n    const options = {\n      comment: 'deep equality',\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    const pass = (0, _jasmineUtils.equals)(received, expected, [_utils.iterableEquality]);\n    const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"Expected: not \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + ((0, _jestMatcherUtils.stringify)(expected) !== (0, _jestMatcherUtils.stringify)(received) ? \"Received:     \".concat((0, _jestMatcherUtils.printReceived)(received)) : '') : () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + (0, _jestMatcherUtils.printDiffOrStringify)(expected, received, EXPECTED_LABEL, RECEIVED_LABEL, isExpand(this.expand)); // Passing the actual and expected objects so that a custom reporter\n    // could access them, for example in order to display a custom visual diff,\n    // or create a different error message\n\n    return {\n      actual: received,\n      expected,\n      message,\n      name: matcherName,\n      pass\n    };\n  },\n\n  toHaveLength(received, expected) {\n    const matcherName = 'toHaveLength';\n    const isNot = this.isNot;\n    const options = {\n      isNot,\n      promise: this.promise\n    };\n\n    if (typeof (received === null || received === void 0 ? void 0 : received.length) !== 'number') {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), \" value must have a length property whose value must be a number\"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n    }\n\n    (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(expected, matcherName, options);\n    const pass = received.length === expected;\n\n    const message = () => {\n      const labelExpected = 'Expected length';\n      const labelReceivedLength = 'Received length';\n      const labelReceivedValue = \"Received \".concat((0, _jestGetType.default)(received));\n      const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceivedLength, labelReceivedValue);\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"\".concat(printLabel(labelExpected)).concat(isNot ? 'not ' : '').concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + (isNot ? '' : \"\".concat(printLabel(labelReceivedLength)).concat((0, _jestMatcherUtils.printReceived)(received.length), \"\\n\")) + \"\".concat(printLabel(labelReceivedValue)).concat(isNot ? '    ' : '').concat((0, _jestMatcherUtils.printReceived)(received));\n    };\n\n    return {\n      message,\n      pass\n    };\n  },\n\n  toHaveProperty(received, expectedPath, expectedValue) {\n    const matcherName = 'toHaveProperty';\n    const expectedArgument = 'path';\n    const hasValue = arguments.length === 3;\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise,\n      secondArgument: hasValue ? 'value' : ''\n    };\n\n    if (received === null || received === undefined) {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), \" value must not be null nor undefined\"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n    }\n\n    const expectedPathType = (0, _jestGetType.default)(expectedPath);\n\n    if (expectedPathType !== 'string' && expectedPathType !== 'array') {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), \"\".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('expected'), \" path must be a string or array\"), (0, _jestMatcherUtils.printWithType)('Expected', expectedPath, _jestMatcherUtils.printExpected)));\n    }\n\n    const expectedPathLength = typeof expectedPath === 'string' ? expectedPath.split('.').length : expectedPath.length;\n\n    if (expectedPathType === 'array' && expectedPathLength === 0) {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), \"\".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('expected'), \" path must not be an empty array\"), (0, _jestMatcherUtils.printWithType)('Expected', expectedPath, _jestMatcherUtils.printExpected)));\n    }\n\n    const result = (0, _utils.getPath)(received, expectedPath);\n    const lastTraversedObject = result.lastTraversedObject,\n          hasEndProp = result.hasEndProp;\n    const receivedPath = result.traversedPath;\n    const hasCompletePath = receivedPath.length === expectedPathLength;\n    const receivedValue = hasCompletePath ? result.value : lastTraversedObject;\n    const pass = hasValue ? (0, _jasmineUtils.equals)(result.value, expectedValue, [_utils.iterableEquality]) : Boolean(hasEndProp); // theoretically undefined if empty path\n    // Remove type cast if we rewrite getPath as iterative algorithm.\n    // Delete this unique report if future breaking change\n    // removes the edge case that expected value undefined\n    // also matches absence of a property with the key path.\n\n    if (pass && !hasCompletePath) {\n      const message = () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\n' + \"Expected path: \".concat((0, _jestMatcherUtils.printExpected)(expectedPath), \"\\n\") + \"Received path: \".concat((0, _jestMatcherUtils.printReceived)(expectedPathType === 'array' || receivedPath.length === 0 ? receivedPath : receivedPath.join('.')), \"\\n\\n\") + \"Expected value: not \".concat((0, _jestMatcherUtils.printExpected)(expectedValue), \"\\n\") + \"Received value:     \".concat((0, _jestMatcherUtils.printReceived)(receivedValue), \"\\n\\n\") + (0, _jestMatcherUtils.DIM_COLOR)('Because a positive assertion passes for expected value undefined if the property does not exist, this negative assertion fails unless the property does exist and has a defined value');\n\n      return {\n        message,\n        pass\n      };\n    }\n\n    const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\n' + (hasValue ? \"Expected path: \".concat((0, _jestMatcherUtils.printExpected)(expectedPath), \"\\n\\n\") + \"Expected value: not \".concat((0, _jestMatcherUtils.printExpected)(expectedValue)) + ((0, _jestMatcherUtils.stringify)(expectedValue) !== (0, _jestMatcherUtils.stringify)(receivedValue) ? \"\\nReceived value:     \".concat((0, _jestMatcherUtils.printReceived)(receivedValue)) : '') : \"Expected path: not \".concat((0, _jestMatcherUtils.printExpected)(expectedPath), \"\\n\\n\") + \"Received value: \".concat((0, _jestMatcherUtils.printReceived)(receivedValue))) : () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\\n\\n' + \"Expected path: \".concat((0, _jestMatcherUtils.printExpected)(expectedPath), \"\\n\") + (hasCompletePath ? '\\n' + (0, _jestMatcherUtils.printDiffOrStringify)(expectedValue, receivedValue, EXPECTED_VALUE_LABEL, RECEIVED_VALUE_LABEL, isExpand(this.expand)) : \"Received path: \".concat((0, _jestMatcherUtils.printReceived)(expectedPathType === 'array' || receivedPath.length === 0 ? receivedPath : receivedPath.join('.')), \"\\n\\n\") + (hasValue ? \"Expected value: \".concat((0, _jestMatcherUtils.printExpected)(expectedValue), \"\\n\") : '') + \"Received value: \".concat((0, _jestMatcherUtils.printReceived)(receivedValue)));\n    return {\n      message,\n      pass\n    };\n  },\n\n  toMatch(received, expected) {\n    const matcherName = 'toMatch';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n\n    if (typeof received !== 'string') {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), \" value must be a string\"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n    }\n\n    if (!(typeof expected === 'string') && !(expected && typeof expected.test === 'function')) {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), \"\".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('expected'), \" value must be a string or regular expression\"), (0, _jestMatcherUtils.printWithType)('Expected', expected, _jestMatcherUtils.printExpected)));\n    }\n\n    const pass = typeof expected === 'string' ? received.includes(expected) : new RegExp(expected).test(received);\n    const message = pass ? () => typeof expected === 'string' ? (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"Expected substring: not \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"Received string:        \".concat((0, _print.printReceivedStringContainExpectedSubstring)(received, received.indexOf(expected), expected.length)) : (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"Expected pattern: not \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"Received string:      \".concat((0, _print.printReceivedStringContainExpectedResult)(received, typeof expected.exec === 'function' ? expected.exec(received) : null)) : () => {\n      const labelExpected = \"Expected \".concat(typeof expected === 'string' ? 'substring' : 'pattern');\n      const labelReceived = 'Received string';\n      const printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceived);\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"\".concat(printLabel(labelExpected)).concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"\".concat(printLabel(labelReceived)).concat((0, _jestMatcherUtils.printReceived)(received));\n    };\n    return {\n      message,\n      pass\n    };\n  },\n\n  toMatchObject(received, expected) {\n    const matcherName = 'toMatchObject';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n\n    if (typeof received !== 'object' || received === null) {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), \" value must be a non-null object\"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n    }\n\n    if (typeof expected !== 'object' || expected === null) {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), \"\".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('expected'), \" value must be a non-null object\"), (0, _jestMatcherUtils.printWithType)('Expected', expected, _jestMatcherUtils.printExpected)));\n    }\n\n    const pass = (0, _jasmineUtils.equals)(received, expected, [_utils.iterableEquality, _utils.subsetEquality]);\n    const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"Expected: not \".concat((0, _jestMatcherUtils.printExpected)(expected)) + ((0, _jestMatcherUtils.stringify)(expected) !== (0, _jestMatcherUtils.stringify)(received) ? \"\\nReceived:     \".concat((0, _jestMatcherUtils.printReceived)(received)) : '') : () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + (0, _jestMatcherUtils.printDiffOrStringify)(expected, (0, _utils.getObjectSubset)(received, expected), EXPECTED_LABEL, RECEIVED_LABEL, isExpand(this.expand));\n    return {\n      message,\n      pass\n    };\n  },\n\n  toStrictEqual(received, expected) {\n    const matcherName = 'toStrictEqual';\n    const options = {\n      comment: 'deep equality',\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    const pass = (0, _jasmineUtils.equals)(received, expected, toStrictEqualTesters, true);\n    const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + \"Expected: not \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + ((0, _jestMatcherUtils.stringify)(expected) !== (0, _jestMatcherUtils.stringify)(received) ? \"Received:     \".concat((0, _jestMatcherUtils.printReceived)(received)) : '') : () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + (0, _jestMatcherUtils.printDiffOrStringify)(expected, received, EXPECTED_LABEL, RECEIVED_LABEL, isExpand(this.expand)); // Passing the actual and expected objects so that a custom reporter\n    // could access them, for example in order to display a custom visual diff,\n    // or create a different error message\n\n    return {\n      actual: received,\n      expected,\n      message,\n      name: matcherName,\n      pass\n    };\n  }\n\n};\nvar _default = matchers;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}
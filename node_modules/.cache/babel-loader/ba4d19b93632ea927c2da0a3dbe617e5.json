{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/brandon/Desktop/ReactProjects/Proj2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar matcherUtils = _interopRequireWildcard(require('jest-matcher-utils'));\n\nvar _utils = require('./utils');\n\nvar _matchers = _interopRequireDefault(require('./matchers'));\n\nvar _spyMatchers = _interopRequireDefault(require('./spyMatchers'));\n\nvar _toThrowMatchers = _interopRequireWildcard(require('./toThrowMatchers'));\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nvar _asymmetricMatchers = require('./asymmetricMatchers');\n\nvar _jestMatchersObject = require('./jestMatchersObject');\n\nvar _extractExpectedAssertionsErrors = _interopRequireDefault(require('./extractExpectedAssertionsErrors'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass JestAssertionError extends Error {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, 'matcherResult', void 0);\n  }\n\n}\n\nconst isPromise = obj => !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n\nconst createToThrowErrorMatchingSnapshotMatcher = function createToThrowErrorMatchingSnapshotMatcher(matcher) {\n  return function (received, testNameOrInlineSnapshot) {\n    return matcher.apply(this, [received, testNameOrInlineSnapshot, true]);\n  };\n};\n\nconst getPromiseMatcher = (name, matcher) => {\n  if (name === 'toThrow' || name === 'toThrowError') {\n    return (0, _toThrowMatchers.createMatcher)(name, true);\n  } else if (name === 'toThrowErrorMatchingSnapshot' || name === 'toThrowErrorMatchingInlineSnapshot') {\n    return createToThrowErrorMatchingSnapshotMatcher(matcher);\n  }\n\n  return null;\n};\n\nconst expect = (actual, ...rest) => {\n  if (rest.length !== 0) {\n    throw new Error('Expect takes at most one argument.');\n  }\n\n  const allMatchers = (0, _jestMatchersObject.getMatchers)();\n  const expectation = {\n    not: {},\n    rejects: {\n      not: {}\n    },\n    resolves: {\n      not: {}\n    }\n  };\n  const err = new JestAssertionError();\n  Object.keys(allMatchers).forEach(name => {\n    const matcher = allMatchers[name];\n    const promiseMatcher = getPromiseMatcher(name, matcher) || matcher;\n    expectation[name] = makeThrowingMatcher(matcher, false, '', actual);\n    expectation.not[name] = makeThrowingMatcher(matcher, true, '', actual);\n    expectation.resolves[name] = makeResolveMatcher(name, promiseMatcher, false, actual, err);\n    expectation.resolves.not[name] = makeResolveMatcher(name, promiseMatcher, true, actual, err);\n    expectation.rejects[name] = makeRejectMatcher(name, promiseMatcher, false, actual, err);\n    expectation.rejects.not[name] = makeRejectMatcher(name, promiseMatcher, true, actual, err);\n  });\n  return expectation;\n};\n\nconst getMessage = message => message && message() || matcherUtils.RECEIVED_COLOR('No message was specified for this matcher.');\n\nconst makeResolveMatcher = (matcherName, matcher, isNot, actual, outerErr) => (...args) => {\n  const options = {\n    isNot,\n    promise: 'resolves'\n  };\n\n  if (!isPromise(actual)) {\n    throw new JestAssertionError(matcherUtils.matcherErrorMessage(matcherUtils.matcherHint(matcherName, undefined, '', options), \"\".concat(matcherUtils.RECEIVED_COLOR('received'), \" value must be a promise\"), matcherUtils.printWithType('Received', actual, matcherUtils.printReceived)));\n  }\n\n  const innerErr = new JestAssertionError();\n  return actual.then(result => makeThrowingMatcher(matcher, isNot, 'resolves', result, innerErr).apply(null, args), reason => {\n    outerErr.message = matcherUtils.matcherHint(matcherName, undefined, '', options) + '\\n\\n' + \"Received promise rejected instead of resolved\\n\" + \"Rejected to value: \".concat(matcherUtils.printReceived(reason));\n    return Promise.reject(outerErr);\n  });\n};\n\nconst makeRejectMatcher = (matcherName, matcher, isNot, actual, outerErr) => (...args) => {\n  const options = {\n    isNot,\n    promise: 'rejects'\n  };\n  const actualWrapper = typeof actual === 'function' ? actual() : actual;\n\n  if (!isPromise(actualWrapper)) {\n    throw new JestAssertionError(matcherUtils.matcherErrorMessage(matcherUtils.matcherHint(matcherName, undefined, '', options), \"\".concat(matcherUtils.RECEIVED_COLOR('received'), \" value must be a promise or a function returning a promise\"), matcherUtils.printWithType('Received', actual, matcherUtils.printReceived)));\n  }\n\n  const innerErr = new JestAssertionError();\n  return actualWrapper.then(result => {\n    outerErr.message = matcherUtils.matcherHint(matcherName, undefined, '', options) + '\\n\\n' + \"Received promise resolved instead of rejected\\n\" + \"Resolved to value: \".concat(matcherUtils.printReceived(result));\n    return Promise.reject(outerErr);\n  }, reason => makeThrowingMatcher(matcher, isNot, 'rejects', reason, innerErr).apply(null, args));\n};\n\nconst makeThrowingMatcher = (matcher, isNot, promise, actual, err) => function throwingMatcher(...args) {\n  let throws = true;\n\n  const utils = _objectSpread(_objectSpread({}, matcherUtils), {}, {\n    iterableEquality: _utils.iterableEquality,\n    subsetEquality: _utils.subsetEquality\n  });\n\n  const matcherContext = _objectSpread(_objectSpread({\n    // When throws is disabled, the matcher will not throw errors during test\n    // execution but instead add them to the global matcher state. If a\n    // matcher throws, test execution is normally stopped immediately. The\n    // snapshot matcher uses it because we want to log all snapshot\n    // failures in a test.\n    dontThrow: () => throws = false\n  }, (0, _jestMatchersObject.getState)()), {}, {\n    equals: _jasmineUtils.equals,\n    error: err,\n    isNot,\n    promise,\n    utils\n  });\n\n  const processResult = (result, asyncError) => {\n    _validateResult(result);\n\n    (0, _jestMatchersObject.getState)().assertionCalls++;\n\n    if (result.pass && isNot || !result.pass && !isNot) {\n      // XOR\n      const message = getMessage(result.message);\n      let error;\n\n      if (err) {\n        error = err;\n        error.message = message;\n      } else if (asyncError) {\n        error = asyncError;\n        error.message = message;\n      } else {\n        error = new JestAssertionError(message); // Try to remove this function from the stack trace frame.\n        // Guard for some environments (browsers) that do not support this feature.\n\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(error, throwingMatcher);\n        }\n      } // Passing the result of the matcher with the error so that a custom\n      // reporter could access the actual and expected objects of the result\n      // for example in order to display a custom visual diff\n\n\n      error.matcherResult = result;\n\n      if (throws) {\n        throw error;\n      } else {\n        (0, _jestMatchersObject.getState)().suppressedErrors.push(error);\n      }\n    }\n  };\n\n  const handleError = error => {\n    if (matcher[_jestMatchersObject.INTERNAL_MATCHER_FLAG] === true && !(error instanceof JestAssertionError) && error.name !== 'PrettyFormatPluginError' && // Guard for some environments (browsers) that do not support this feature.\n    Error.captureStackTrace) {\n      // Try to remove this and deeper functions from the stack trace frame.\n      Error.captureStackTrace(error, throwingMatcher);\n    }\n\n    throw error;\n  };\n\n  let potentialResult;\n\n  try {\n    potentialResult = matcher[_jestMatchersObject.INTERNAL_MATCHER_FLAG] === true ? matcher.call(matcherContext, actual, ...args) // It's a trap specifically for inline snapshot to capture this name\n    : // in the stack trace, so that it can correctly get the custom matcher\n    // function call.\n    function __EXTERNAL_MATCHER_TRAP__() {\n      return matcher.call(matcherContext, actual, ...args);\n    }();\n\n    if (isPromise(potentialResult)) {\n      const asyncResult = potentialResult;\n      const asyncError = new JestAssertionError();\n\n      if (Error.captureStackTrace) {\n        Error.captureStackTrace(asyncError, throwingMatcher);\n      }\n\n      return asyncResult.then(aResult => processResult(aResult, asyncError)).catch(error => handleError(error));\n    } else {\n      const syncResult = potentialResult;\n      return processResult(syncResult);\n    }\n  } catch (error) {\n    return handleError(error);\n  }\n};\n\nexpect.extend = matchers => (0, _jestMatchersObject.setMatchers)(matchers, false, expect);\n\nexpect.anything = _asymmetricMatchers.anything;\nexpect.any = _asymmetricMatchers.any;\nexpect.not = {\n  arrayContaining: _asymmetricMatchers.arrayNotContaining,\n  objectContaining: _asymmetricMatchers.objectNotContaining,\n  stringContaining: _asymmetricMatchers.stringNotContaining,\n  stringMatching: _asymmetricMatchers.stringNotMatching\n};\nexpect.objectContaining = _asymmetricMatchers.objectContaining;\nexpect.arrayContaining = _asymmetricMatchers.arrayContaining;\nexpect.stringContaining = _asymmetricMatchers.stringContaining;\nexpect.stringMatching = _asymmetricMatchers.stringMatching;\n\nconst _validateResult = result => {\n  if (typeof result !== 'object' || typeof result.pass !== 'boolean' || result.message && typeof result.message !== 'string' && typeof result.message !== 'function') {\n    throw new Error('Unexpected return from a matcher function.\\n' + 'Matcher functions should ' + 'return an object in the following format:\\n' + '  {message?: string | function, pass: boolean}\\n' + \"'\".concat(matcherUtils.stringify(result), \"' was returned\"));\n  }\n};\n\nfunction assertions(expected) {\n  const error = new Error();\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(error, assertions);\n  }\n\n  (0, _jestMatchersObject.getState)().expectedAssertionsNumber = expected;\n  (0, _jestMatchersObject.getState)().expectedAssertionsNumberError = error;\n}\n\nfunction hasAssertions(...args) {\n  const error = new Error();\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(error, hasAssertions);\n  }\n\n  matcherUtils.ensureNoExpected(args[0], '.hasAssertions');\n  (0, _jestMatchersObject.getState)().isExpectingAssertions = true;\n  (0, _jestMatchersObject.getState)().isExpectingAssertionsError = error;\n} // add default jest matchers\n\n\n(0, _jestMatchersObject.setMatchers)(_matchers.default, true, expect);\n(0, _jestMatchersObject.setMatchers)(_spyMatchers.default, true, expect);\n(0, _jestMatchersObject.setMatchers)(_toThrowMatchers.default, true, expect);\n\nexpect.addSnapshotSerializer = () => void 0;\n\nexpect.assertions = assertions;\nexpect.hasAssertions = hasAssertions;\nexpect.getState = _jestMatchersObject.getState;\nexpect.setState = _jestMatchersObject.setState;\nexpect.extractExpectedAssertionsErrors = _extractExpectedAssertionsErrors.default;\nconst expectExport = expect; // eslint-disable-next-line no-redeclare\n\nmodule.exports = expectExport;","map":null,"metadata":{},"sourceType":"script"}
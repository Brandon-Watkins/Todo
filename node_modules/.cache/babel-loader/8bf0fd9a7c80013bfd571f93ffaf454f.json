{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.diffStringsRaw = exports.diffStringsUnified = exports.createPatchMark = exports.printDiffLines = exports.printAnnotation = exports.countChanges = exports.hasCommonDiff = exports.printCommonLine = exports.printInsertLine = exports.printDeleteLine = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _diffLines = require('./diffLines');\n\nvar _diffStrings = _interopRequireDefault(require('./diffStrings'));\n\nvar _getAlignedDiffs = _interopRequireDefault(require('./getAlignedDiffs'));\n\nvar _joinAlignedDiffs = require('./joinAlignedDiffs');\n\nvar _normalizeDiffOptions = require('./normalizeDiffOptions');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst formatTrailingSpaces = (line, trailingSpaceFormatter) => line.replace(/\\s+$/, match => trailingSpaceFormatter(match));\n\nconst printDiffLine = (line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) => line.length !== 0 ? color(indicator + ' ' + formatTrailingSpaces(line, trailingSpaceFormatter)) : indicator !== ' ' ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(indicator + ' ' + emptyFirstOrLastLinePlaceholder) : '';\n\nconst printDeleteLine = (line, isFirstOrLast, {\n  aColor,\n  aIndicator,\n  changeLineTrailingSpaceColor,\n  emptyFirstOrLastLinePlaceholder\n}) => printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n\nexports.printDeleteLine = printDeleteLine;\n\nconst printInsertLine = (line, isFirstOrLast, {\n  bColor,\n  bIndicator,\n  changeLineTrailingSpaceColor,\n  emptyFirstOrLastLinePlaceholder\n}) => printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n\nexports.printInsertLine = printInsertLine;\n\nconst printCommonLine = (line, isFirstOrLast, {\n  commonColor,\n  commonIndicator,\n  commonLineTrailingSpaceColor,\n  emptyFirstOrLastLinePlaceholder\n}) => printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n\nexports.printCommonLine = printCommonLine;\n\nconst hasCommonDiff = (diffs, isMultiline) => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some((diff, i) => diff[0] === _cleanupSemantic.DIFF_EQUAL && (i !== iLast || diff[1] !== '\\n'));\n  }\n\n  return diffs.some(diff => diff[0] === _cleanupSemantic.DIFF_EQUAL);\n};\n\nexports.hasCommonDiff = hasCommonDiff;\n\nconst countChanges = diffs => {\n  let a = 0;\n  let b = 0;\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        a += 1;\n        break;\n\n      case _cleanupSemantic.DIFF_INSERT:\n        b += 1;\n        break;\n    }\n  });\n  return {\n    a,\n    b\n  };\n};\n\nexports.countChanges = countChanges;\n\nconst printAnnotation = ({\n  aAnnotation,\n  aColor,\n  aIndicator,\n  bAnnotation,\n  bColor,\n  bIndicator,\n  includeChangeCounts,\n  omitAnnotationLines\n}, changeCounts) => {\n  if (omitAnnotationLines) {\n    return '';\n  }\n\n  let aRest = '';\n  let bRest = '';\n\n  if (includeChangeCounts) {\n    const aCount = String(changeCounts.a);\n    const bCount = String(changeCounts.b); // Padding right aligns the ends of the annotations.\n\n    const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;\n    const aAnnotationPadding = ' '.repeat(Math.max(0, baAnnotationLengthDiff));\n    const bAnnotationPadding = ' '.repeat(Math.max(0, -baAnnotationLengthDiff)); // Padding left aligns the ends of the counts.\n\n    const baCountLengthDiff = bCount.length - aCount.length;\n    const aCountPadding = ' '.repeat(Math.max(0, baCountLengthDiff));\n    const bCountPadding = ' '.repeat(Math.max(0, -baCountLengthDiff));\n    aRest = aAnnotationPadding + '  ' + aIndicator + ' ' + aCountPadding + aCount;\n    bRest = bAnnotationPadding + '  ' + bIndicator + ' ' + bCountPadding + bCount;\n  }\n\n  return aColor(aIndicator + ' ' + aAnnotation + aRest) + '\\n' + bColor(bIndicator + ' ' + bAnnotation + bRest) + '\\n\\n';\n};\n\nexports.printAnnotation = printAnnotation;\n\nconst printDiffLines = (diffs, options) => printAnnotation(options, countChanges(diffs)) + (options.expand ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(diffs, options) : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(diffs, options)); // In GNU diff format, indexes are one-based instead of zero-based.\n\n\nexports.printDiffLines = printDiffLines;\n\nconst createPatchMark = (aStart, aEnd, bStart, bEnd, {\n  patchColor\n}) => patchColor(\"@@ -\".concat(aStart + 1, \",\").concat(aEnd - aStart, \" +\").concat(bStart + 1, \",\").concat(bEnd - bStart, \" @@\")); // Compare two strings character-by-character.\n// Format as comparison lines in which changed substrings have inverse colors.\n\n\nexports.createPatchMark = createPatchMark;\n\nconst diffStringsUnified = (a, b, options) => {\n  if (a !== b && a.length !== 0 && b.length !== 0) {\n    const isMultiline = a.includes('\\n') || b.includes('\\n'); // getAlignedDiffs assumes that a newline was appended to the strings.\n\n    const diffs = diffStringsRaw(isMultiline ? a + '\\n' : a, isMultiline ? b + '\\n' : b, true // cleanupSemantic\n    );\n\n    if (hasCommonDiff(diffs, isMultiline)) {\n      const optionsNormalized = (0, _normalizeDiffOptions.normalizeDiffOptions)(options);\n      const lines = (0, _getAlignedDiffs.default)(diffs, optionsNormalized.changeColor);\n      return printDiffLines(lines, optionsNormalized);\n    }\n  } // Fall back to line-by-line diff.\n\n\n  return (0, _diffLines.diffLinesUnified)(a.split('\\n'), b.split('\\n'), options);\n}; // Compare two strings character-by-character.\n// Optionally clean up small common substrings, also known as chaff.\n\n\nexports.diffStringsUnified = diffStringsUnified;\n\nconst diffStringsRaw = (a, b, cleanup) => {\n  const diffs = (0, _diffStrings.default)(a, b);\n\n  if (cleanup) {\n    (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function\n  }\n\n  return diffs;\n};\n\nexports.diffStringsRaw = diffStringsRaw;","map":null,"metadata":{},"sourceType":"script"}
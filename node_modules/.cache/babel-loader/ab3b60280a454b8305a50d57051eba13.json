{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.stringNotMatching = exports.stringMatching = exports.stringNotContaining = exports.stringContaining = exports.objectNotContaining = exports.objectContaining = exports.arrayNotContaining = exports.arrayContaining = exports.anything = exports.any = exports.AsymmetricMatcher = void 0;\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nvar _utils = require('./utils');\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass AsymmetricMatcher {\n  constructor(sample) {\n    _defineProperty(this, 'sample', void 0);\n\n    _defineProperty(this, '$$typeof', void 0);\n\n    _defineProperty(this, 'inverse', void 0);\n\n    this.$$typeof = Symbol.for('jest.asymmetricMatcher');\n    this.sample = sample;\n  }\n\n}\n\nexports.AsymmetricMatcher = AsymmetricMatcher;\n\nclass Any extends AsymmetricMatcher {\n  constructor(sample) {\n    if (typeof sample === 'undefined') {\n      throw new TypeError('any() expects to be passed a constructor function. ' + 'Please pass one or use anything() to match any object.');\n    }\n\n    super(sample);\n  }\n\n  asymmetricMatch(other) {\n    if (this.sample == String) {\n      return typeof other == 'string' || other instanceof String;\n    }\n\n    if (this.sample == Number) {\n      return typeof other == 'number' || other instanceof Number;\n    }\n\n    if (this.sample == Function) {\n      return typeof other == 'function' || other instanceof Function;\n    }\n\n    if (this.sample == Object) {\n      return typeof other == 'object';\n    }\n\n    if (this.sample == Boolean) {\n      return typeof other == 'boolean';\n    }\n    /* global BigInt */\n\n\n    if (this.sample == BigInt) {\n      return typeof other == 'bigint';\n    }\n\n    if (this.sample == Symbol) {\n      return typeof other == 'symbol';\n    }\n\n    return other instanceof this.sample;\n  }\n\n  toString() {\n    return 'Any';\n  }\n\n  getExpectedType() {\n    if (this.sample == String) {\n      return 'string';\n    }\n\n    if (this.sample == Number) {\n      return 'number';\n    }\n\n    if (this.sample == Function) {\n      return 'function';\n    }\n\n    if (this.sample == Object) {\n      return 'object';\n    }\n\n    if (this.sample == Boolean) {\n      return 'boolean';\n    }\n\n    return (0, _jasmineUtils.fnNameFor)(this.sample);\n  }\n\n  toAsymmetricMatcher() {\n    return 'Any<' + (0, _jasmineUtils.fnNameFor)(this.sample) + '>';\n  }\n\n}\n\nclass Anything extends AsymmetricMatcher {\n  asymmetricMatch(other) {\n    return !(0, _jasmineUtils.isUndefined)(other) && other !== null;\n  }\n\n  toString() {\n    return 'Anything';\n  } // No getExpectedType method, because it matches either null or undefined.\n\n\n  toAsymmetricMatcher() {\n    return 'Anything';\n  }\n\n}\n\nclass ArrayContaining extends AsymmetricMatcher {\n  constructor(sample, inverse = false) {\n    super(sample);\n    this.inverse = inverse;\n  }\n\n  asymmetricMatch(other) {\n    if (!Array.isArray(this.sample)) {\n      throw new Error(\"You must provide an array to \".concat(this.toString(), \", not '\") + typeof this.sample + \"'.\");\n    }\n\n    const result = this.sample.length === 0 || Array.isArray(other) && this.sample.every(item => other.some(another => (0, _jasmineUtils.equals)(item, another)));\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return \"Array\".concat(this.inverse ? 'Not' : '', \"Containing\");\n  }\n\n  getExpectedType() {\n    return 'array';\n  }\n\n}\n\nclass ObjectContaining extends AsymmetricMatcher {\n  constructor(sample, inverse = false) {\n    super(sample);\n    this.inverse = inverse;\n  }\n\n  asymmetricMatch(other) {\n    if (typeof this.sample !== 'object') {\n      throw new Error(\"You must provide an object to \".concat(this.toString(), \", not '\") + typeof this.sample + \"'.\");\n    }\n\n    if (this.inverse) {\n      for (const property in this.sample) {\n        if ((0, _jasmineUtils.hasProperty)(other, property) && (0, _jasmineUtils.equals)(this.sample[property], other[property]) && !(0, _utils.emptyObject)(this.sample[property]) && !(0, _utils.emptyObject)(other[property])) {\n          return false;\n        }\n      }\n\n      return true;\n    } else {\n      for (const property in this.sample) {\n        if (!(0, _jasmineUtils.hasProperty)(other, property) || !(0, _jasmineUtils.equals)(this.sample[property], other[property])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  toString() {\n    return \"Object\".concat(this.inverse ? 'Not' : '', \"Containing\");\n  }\n\n  getExpectedType() {\n    return 'object';\n  }\n\n}\n\nclass StringContaining extends AsymmetricMatcher {\n  constructor(sample, inverse = false) {\n    if (!(0, _jasmineUtils.isA)('String', sample)) {\n      throw new Error('Expected is not a string');\n    }\n\n    super(sample);\n    this.inverse = inverse;\n  }\n\n  asymmetricMatch(other) {\n    const result = (0, _jasmineUtils.isA)('String', other) && other.includes(this.sample);\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return \"String\".concat(this.inverse ? 'Not' : '', \"Containing\");\n  }\n\n  getExpectedType() {\n    return 'string';\n  }\n\n}\n\nclass StringMatching extends AsymmetricMatcher {\n  constructor(sample, inverse = false) {\n    if (!(0, _jasmineUtils.isA)('String', sample) && !(0, _jasmineUtils.isA)('RegExp', sample)) {\n      throw new Error('Expected is not a String or a RegExp');\n    }\n\n    super(new RegExp(sample));\n    this.inverse = inverse;\n  }\n\n  asymmetricMatch(other) {\n    const result = (0, _jasmineUtils.isA)('String', other) && this.sample.test(other);\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return \"String\".concat(this.inverse ? 'Not' : '', \"Matching\");\n  }\n\n  getExpectedType() {\n    return 'string';\n  }\n\n}\n\nconst any = expectedObject => new Any(expectedObject);\n\nexports.any = any;\n\nconst anything = () => new Anything();\n\nexports.anything = anything;\n\nconst arrayContaining = sample => new ArrayContaining(sample);\n\nexports.arrayContaining = arrayContaining;\n\nconst arrayNotContaining = sample => new ArrayContaining(sample, true);\n\nexports.arrayNotContaining = arrayNotContaining;\n\nconst objectContaining = sample => new ObjectContaining(sample);\n\nexports.objectContaining = objectContaining;\n\nconst objectNotContaining = sample => new ObjectContaining(sample, true);\n\nexports.objectNotContaining = objectNotContaining;\n\nconst stringContaining = expected => new StringContaining(expected);\n\nexports.stringContaining = stringContaining;\n\nconst stringNotContaining = expected => new StringContaining(expected, true);\n\nexports.stringNotContaining = stringNotContaining;\n\nconst stringMatching = expected => new StringMatching(expected);\n\nexports.stringMatching = stringMatching;\n\nconst stringNotMatching = expected => new StringMatching(expected, true);\n\nexports.stringNotMatching = stringNotMatching;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _jestGetType = _interopRequireDefault(require('jest-get-type'));\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// The optional property of matcher context is true if undefined.\n\n\nconst isExpand = expand => expand !== false;\n\nconst PRINT_LIMIT = 3;\nconst NO_ARGUMENTS = 'called with 0 arguments';\n\nconst printExpectedArgs = expected => expected.length === 0 ? NO_ARGUMENTS : expected.map(arg => (0, _jestMatcherUtils.printExpected)(arg)).join(', ');\n\nconst printReceivedArgs = (received, expected) => received.length === 0 ? NO_ARGUMENTS : received.map((arg, i) => Array.isArray(expected) && i < expected.length && isEqualValue(expected[i], arg) ? printCommon(arg) : (0, _jestMatcherUtils.printReceived)(arg)).join(', ');\n\nconst printCommon = val => (0, _jestMatcherUtils.DIM_COLOR)((0, _jestMatcherUtils.stringify)(val));\n\nconst isEqualValue = (expected, received) => (0, _jasmineUtils.equals)(expected, received, [_utils.iterableEquality]);\n\nconst isEqualCall = (expected, received) => isEqualValue(expected, received);\n\nconst isEqualReturn = (expected, result) => result.type === 'return' && isEqualValue(expected, result.value);\n\nconst countReturns = results => results.reduce((n, result) => result.type === 'return' ? n + 1 : n, 0);\n\nconst printNumberOfReturns = (countReturns, countCalls) => \"\\nNumber of returns: \".concat((0, _jestMatcherUtils.printReceived)(countReturns)) + (countCalls !== countReturns ? \"\\nNumber of calls:   \".concat((0, _jestMatcherUtils.printReceived)(countCalls)) : ''); // Given a label, return a function which given a string,\n// right-aligns it preceding the colon in the label.\n\n\nconst getRightAlignedPrinter = label => {\n  // Assume that the label contains a colon.\n  const index = label.indexOf(':');\n  const suffix = label.slice(index);\n  return (string, isExpectedCall) => (isExpectedCall ? '->' + ' '.repeat(Math.max(0, index - 2 - string.length)) : ' '.repeat(Math.max(index - string.length))) + string + suffix;\n};\n\nconst printReceivedCallsNegative = (expected, indexedCalls, isOnlyCall, iExpectedCall) => {\n  if (indexedCalls.length === 0) {\n    return '';\n  }\n\n  const label = 'Received:     ';\n\n  if (isOnlyCall) {\n    return label + printReceivedArgs(indexedCalls[0], expected) + '\\n';\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n  return 'Received\\n' + indexedCalls.reduce((printed, [i, args]) => printed + printAligned(String(i + 1), i === iExpectedCall) + printReceivedArgs(args, expected) + '\\n', '');\n};\n\nconst printExpectedReceivedCallsPositive = (expected, indexedCalls, expand, isOnlyCall, iExpectedCall) => {\n  const expectedLine = \"Expected: \".concat(printExpectedArgs(expected), \"\\n\");\n\n  if (indexedCalls.length === 0) {\n    return expectedLine;\n  }\n\n  const label = 'Received: ';\n\n  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n    const received = indexedCalls[0][1];\n\n    if (isLineDiffableCall(expected, received)) {\n      // Display diff without indentation.\n      const lines = [(0, _jestMatcherUtils.EXPECTED_COLOR)('- Expected'), (0, _jestMatcherUtils.RECEIVED_COLOR)('+ Received'), ''];\n      const length = Math.max(expected.length, received.length);\n\n      for (let i = 0; i < length; i += 1) {\n        if (i < expected.length && i < received.length) {\n          if (isEqualValue(expected[i], received[i])) {\n            lines.push(\"  \".concat(printCommon(received[i]), \",\"));\n            continue;\n          }\n\n          if (isLineDiffableArg(expected[i], received[i])) {\n            const difference = (0, _jestMatcherUtils.diff)(expected[i], received[i], {\n              expand\n            });\n\n            if (typeof difference === 'string' && difference.includes('- Expected') && difference.includes('+ Received')) {\n              // Omit annotation in case multiple args have diff.\n              lines.push(difference.split('\\n').slice(3).join('\\n') + ',');\n              continue;\n            }\n          }\n        }\n\n        if (i < expected.length) {\n          lines.push((0, _jestMatcherUtils.EXPECTED_COLOR)('- ' + (0, _jestMatcherUtils.stringify)(expected[i])) + ',');\n        }\n\n        if (i < received.length) {\n          lines.push((0, _jestMatcherUtils.RECEIVED_COLOR)('+ ' + (0, _jestMatcherUtils.stringify)(received[i])) + ',');\n        }\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n\n    return expectedLine + label + printReceivedArgs(received, expected) + '\\n';\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n  return expectedLine + 'Received\\n' + indexedCalls.reduce((printed, [i, received]) => {\n    const aligned = printAligned(String(i + 1), i === iExpectedCall);\n    return printed + ((i === iExpectedCall || iExpectedCall === undefined) && isLineDiffableCall(expected, received) ? aligned.replace(': ', '\\n') + printDiffCall(expected, received, expand) : aligned + printReceivedArgs(received, expected)) + '\\n';\n  }, '');\n};\n\nconst indentation = 'Received'.replace(/\\w/g, ' ');\n\nconst printDiffCall = (expected, received, expand) => received.map((arg, i) => {\n  if (i < expected.length) {\n    if (isEqualValue(expected[i], arg)) {\n      return indentation + '  ' + printCommon(arg) + ',';\n    }\n\n    if (isLineDiffableArg(expected[i], arg)) {\n      const difference = (0, _jestMatcherUtils.diff)(expected[i], arg, {\n        expand\n      });\n\n      if (typeof difference === 'string' && difference.includes('- Expected') && difference.includes('+ Received')) {\n        // Display diff with indentation.\n        // Omit annotation in case multiple args have diff.\n        return difference.split('\\n').slice(3).map(line => indentation + line).join('\\n') + ',';\n      }\n    }\n  } // Display + only if received arg has no corresponding expected arg.\n\n\n  return indentation + (i < expected.length ? '  ' + (0, _jestMatcherUtils.printReceived)(arg) : (0, _jestMatcherUtils.RECEIVED_COLOR)('+ ' + (0, _jestMatcherUtils.stringify)(arg))) + ',';\n}).join('\\n');\n\nconst isLineDiffableCall = (expected, received) => expected.some((arg, i) => i < received.length && isLineDiffableArg(arg, received[i])); // Almost redundant with function in jest-matcher-utils,\n// except no line diff for any strings.\n\n\nconst isLineDiffableArg = (expected, received) => {\n  const expectedType = (0, _jestGetType.default)(expected);\n  const receivedType = (0, _jestGetType.default)(received);\n\n  if (expectedType !== receivedType) {\n    return false;\n  }\n\n  if (_jestGetType.default.isPrimitive(expected)) {\n    return false;\n  }\n\n  if (expectedType === 'date' || expectedType === 'function' || expectedType === 'regexp') {\n    return false;\n  }\n\n  if (expected instanceof Error && received instanceof Error) {\n    return false;\n  }\n\n  if (expectedType === 'object' && typeof expected.asymmetricMatch === 'function') {\n    return false;\n  }\n\n  if (receivedType === 'object' && typeof received.asymmetricMatch === 'function') {\n    return false;\n  }\n\n  return true;\n};\n\nconst printResult = (result, expected) => result.type === 'throw' ? 'function call threw an error' : result.type === 'incomplete' ? 'function call has not returned yet' : isEqualValue(expected, result.value) ? printCommon(result.value) : (0, _jestMatcherUtils.printReceived)(result.value); // Return either empty string or one line per indexed result,\n// so additional empty line can separate from `Number of returns` which follows.\n\n\nconst printReceivedResults = (label, expected, indexedResults, isOnlyCall, iExpectedCall) => {\n  if (indexedResults.length === 0) {\n    return '';\n  }\n\n  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n    return label + printResult(indexedResults[0][1], expected) + '\\n';\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n  return label.replace(':', '').trim() + '\\n' + indexedResults.reduce((printed, [i, result]) => printed + printAligned(String(i + 1), i === iExpectedCall) + printResult(result, expected) + '\\n', '');\n};\n\nconst createToBeCalledMatcher = matcherName => function (received, expected) {\n  const expectedArgument = '';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n  ensureMockOrSpy(received, matcherName, expectedArgument, options);\n  const receivedIsSpy = isSpy(received);\n  const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n  const count = receivedIsSpy ? received.calls.count() : received.mock.calls.length;\n  const calls = receivedIsSpy ? received.calls.all().map(x => x.args) : received.mock.calls;\n  const pass = count > 0;\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected number of calls: \".concat((0, _jestMatcherUtils.printExpected)(0), \"\\n\") + \"Received number of calls: \".concat((0, _jestMatcherUtils.printReceived)(count), \"\\n\\n\") + calls.reduce((lines, args, i) => {\n    if (lines.length < PRINT_LIMIT) {\n      lines.push(\"\".concat(i + 1, \": \").concat(printReceivedArgs(args)));\n    }\n\n    return lines;\n  }, []).join('\\n') : () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected number of calls: >= \".concat((0, _jestMatcherUtils.printExpected)(1), \"\\n\") + \"Received number of calls:    \".concat((0, _jestMatcherUtils.printReceived)(count));\n  return {\n    message,\n    pass\n  };\n};\n\nconst createToReturnMatcher = matcherName => function (received, expected) {\n  const expectedArgument = '';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n  ensureMock(received, matcherName, expectedArgument, options);\n  const receivedName = received.getMockName(); // Count return values that correspond only to calls that returned\n\n  const count = received.mock.results.reduce((n, result) => result.type === 'return' ? n + 1 : n, 0);\n  const pass = count > 0;\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected number of returns: \".concat((0, _jestMatcherUtils.printExpected)(0), \"\\n\") + \"Received number of returns: \".concat((0, _jestMatcherUtils.printReceived)(count), \"\\n\\n\") + received.mock.results.reduce((lines, result, i) => {\n    if (result.type === 'return' && lines.length < PRINT_LIMIT) {\n      lines.push(\"\".concat(i + 1, \": \").concat((0, _jestMatcherUtils.printReceived)(result.value)));\n    }\n\n    return lines;\n  }, []).join('\\n') + (received.mock.calls.length !== count ? \"\\n\\nReceived number of calls:   \".concat((0, _jestMatcherUtils.printReceived)(received.mock.calls.length)) : '') : () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected number of returns: >= \".concat((0, _jestMatcherUtils.printExpected)(1), \"\\n\") + \"Received number of returns:    \".concat((0, _jestMatcherUtils.printReceived)(count)) + (received.mock.calls.length !== count ? \"\\nReceived number of calls:      \".concat((0, _jestMatcherUtils.printReceived)(received.mock.calls.length)) : '');\n  return {\n    message,\n    pass\n  };\n};\n\nconst createToBeCalledTimesMatcher = matcherName => function (received, expected) {\n  const expectedArgument = 'expected';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(expected, matcherName, options);\n  ensureMockOrSpy(received, matcherName, expectedArgument, options);\n  const receivedIsSpy = isSpy(received);\n  const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n  const count = receivedIsSpy ? received.calls.count() : received.mock.calls.length;\n  const pass = count === expected;\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + \"\\n\\n\" + \"Expected number of calls: not \".concat((0, _jestMatcherUtils.printExpected)(expected)) : () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected number of calls: \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"Received number of calls: \".concat((0, _jestMatcherUtils.printReceived)(count));\n  return {\n    message,\n    pass\n  };\n};\n\nconst createToReturnTimesMatcher = matcherName => function (received, expected) {\n  const expectedArgument = 'expected';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(expected, matcherName, options);\n  ensureMock(received, matcherName, expectedArgument, options);\n  const receivedName = received.getMockName(); // Count return values that correspond only to calls that returned\n\n  const count = received.mock.results.reduce((n, result) => result.type === 'return' ? n + 1 : n, 0);\n  const pass = count === expected;\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + \"\\n\\n\" + \"Expected number of returns: not \".concat((0, _jestMatcherUtils.printExpected)(expected)) + (received.mock.calls.length !== count ? \"\\n\\nReceived number of calls:       \".concat((0, _jestMatcherUtils.printReceived)(received.mock.calls.length)) : '') : () => (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected number of returns: \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"Received number of returns: \".concat((0, _jestMatcherUtils.printReceived)(count)) + (received.mock.calls.length !== count ? \"\\nReceived number of calls:   \".concat((0, _jestMatcherUtils.printReceived)(received.mock.calls.length)) : '');\n  return {\n    message,\n    pass\n  };\n};\n\nconst createToBeCalledWithMatcher = matcherName => function (received, ...expected) {\n  const expectedArgument = '...expected';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  ensureMockOrSpy(received, matcherName, expectedArgument, options);\n  const receivedIsSpy = isSpy(received);\n  const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n  const calls = receivedIsSpy ? received.calls.all().map(x => x.args) : received.mock.calls;\n  const pass = calls.some(call => isEqualCall(expected, call));\n  const message = pass ? () => {\n    // Some examples of calls that are equal to expected value.\n    const indexedCalls = [];\n    let i = 0;\n\n    while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {\n      if (isEqualCall(expected, calls[i])) {\n        indexedCalls.push([i, calls[i]]);\n      }\n\n      i += 1;\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected: not \".concat(printExpectedArgs(expected), \"\\n\") + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1)) + \"\\nNumber of calls: \".concat((0, _jestMatcherUtils.printReceived)(calls.length));\n  } : () => {\n    // Some examples of calls that are not equal to expected value.\n    const indexedCalls = [];\n    let i = 0;\n\n    while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {\n      indexedCalls.push([i, calls[i]]);\n      i += 1;\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(this.expand), calls.length === 1) + \"\\nNumber of calls: \".concat((0, _jestMatcherUtils.printReceived)(calls.length));\n  };\n  return {\n    message,\n    pass\n  };\n};\n\nconst createToReturnWithMatcher = matcherName => function (received, expected) {\n  const expectedArgument = 'expected';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  ensureMock(received, matcherName, expectedArgument, options);\n  const receivedName = received.getMockName();\n  const _received$mock = received.mock,\n        calls = _received$mock.calls,\n        results = _received$mock.results;\n  const pass = results.some(result => isEqualReturn(expected, result));\n  const message = pass ? () => {\n    // Some examples of results that are equal to expected value.\n    const indexedResults = [];\n    let i = 0;\n\n    while (i < results.length && indexedResults.length < PRINT_LIMIT) {\n      if (isEqualReturn(expected, results[i])) {\n        indexedResults.push([i, results[i]]);\n      }\n\n      i += 1;\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected: not \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + (results.length === 1 && results[0].type === 'return' && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedResults('Received:     ', expected, indexedResults, results.length === 1)) + printNumberOfReturns(countReturns(results), calls.length);\n  } : () => {\n    // Some examples of results that are not equal to expected value.\n    const indexedResults = [];\n    let i = 0;\n\n    while (i < results.length && indexedResults.length < PRINT_LIMIT) {\n      indexedResults.push([i, results[i]]);\n      i += 1;\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected: \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + printReceivedResults('Received: ', expected, indexedResults, results.length === 1) + printNumberOfReturns(countReturns(results), calls.length);\n  };\n  return {\n    message,\n    pass\n  };\n};\n\nconst createLastCalledWithMatcher = matcherName => function (received, ...expected) {\n  const expectedArgument = '...expected';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  ensureMockOrSpy(received, matcherName, expectedArgument, options);\n  const receivedIsSpy = isSpy(received);\n  const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n  const calls = receivedIsSpy ? received.calls.all().map(x => x.args) : received.mock.calls;\n  const iLast = calls.length - 1;\n  const pass = iLast >= 0 && isEqualCall(expected, calls[iLast]);\n  const message = pass ? () => {\n    const indexedCalls = [];\n\n    if (iLast > 0) {\n      // Display preceding call as context.\n      indexedCalls.push([iLast - 1, calls[iLast - 1]]);\n    }\n\n    indexedCalls.push([iLast, calls[iLast]]);\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected: not \".concat(printExpectedArgs(expected), \"\\n\") + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1, iLast)) + \"\\nNumber of calls: \".concat((0, _jestMatcherUtils.printReceived)(calls.length));\n  } : () => {\n    const indexedCalls = [];\n\n    if (iLast >= 0) {\n      if (iLast > 0) {\n        let i = iLast - 1; // Is there a preceding call that is equal to expected args?\n\n        while (i >= 0 && !isEqualCall(expected, calls[i])) {\n          i -= 1;\n        }\n\n        if (i < 0) {\n          i = iLast - 1; // otherwise, preceding call\n        }\n\n        indexedCalls.push([i, calls[i]]);\n      }\n\n      indexedCalls.push([iLast, calls[iLast]]);\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(this.expand), calls.length === 1, iLast) + \"\\nNumber of calls: \".concat((0, _jestMatcherUtils.printReceived)(calls.length));\n  };\n  return {\n    message,\n    pass\n  };\n};\n\nconst createLastReturnedMatcher = matcherName => function (received, expected) {\n  const expectedArgument = 'expected';\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  ensureMock(received, matcherName, expectedArgument, options);\n  const receivedName = received.getMockName();\n  const _received$mock2 = received.mock,\n        calls = _received$mock2.calls,\n        results = _received$mock2.results;\n  const iLast = results.length - 1;\n  const pass = iLast >= 0 && isEqualReturn(expected, results[iLast]);\n  const message = pass ? () => {\n    const indexedResults = [];\n\n    if (iLast > 0) {\n      // Display preceding result as context.\n      indexedResults.push([iLast - 1, results[iLast - 1]]);\n    }\n\n    indexedResults.push([iLast, results[iLast]]);\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected: not \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + (results.length === 1 && results[0].type === 'return' && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedResults('Received:     ', expected, indexedResults, results.length === 1, iLast)) + printNumberOfReturns(countReturns(results), calls.length);\n  } : () => {\n    const indexedResults = [];\n\n    if (iLast >= 0) {\n      if (iLast > 0) {\n        let i = iLast - 1; // Is there a preceding result that is equal to expected value?\n\n        while (i >= 0 && !isEqualReturn(expected, results[i])) {\n          i -= 1;\n        }\n\n        if (i < 0) {\n          i = iLast - 1; // otherwise, preceding result\n        }\n\n        indexedResults.push([i, results[i]]);\n      }\n\n      indexedResults.push([iLast, results[iLast]]);\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected: \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + printReceivedResults('Received: ', expected, indexedResults, results.length === 1, iLast) + printNumberOfReturns(countReturns(results), calls.length);\n  };\n  return {\n    message,\n    pass\n  };\n};\n\nconst createNthCalledWithMatcher = matcherName => function (received, nth, ...expected) {\n  const expectedArgument = 'n';\n  const options = {\n    expectedColor: arg => arg,\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument: '...expected'\n  };\n  ensureMockOrSpy(received, matcherName, expectedArgument, options);\n\n  if (!Number.isSafeInteger(nth) || nth < 1) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), \"\".concat(expectedArgument, \" must be a positive integer\"), (0, _jestMatcherUtils.printWithType)(expectedArgument, nth, _jestMatcherUtils.stringify)));\n  }\n\n  const receivedIsSpy = isSpy(received);\n  const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n  const calls = receivedIsSpy ? received.calls.all().map(x => x.args) : received.mock.calls;\n  const length = calls.length;\n  const iNth = nth - 1;\n  const pass = iNth < length && isEqualCall(expected, calls[iNth]);\n  const message = pass ? () => {\n    // Display preceding and following calls,\n    // in case assertions fails because index is off by one.\n    const indexedCalls = [];\n\n    if (iNth - 1 >= 0) {\n      indexedCalls.push([iNth - 1, calls[iNth - 1]]);\n    }\n\n    indexedCalls.push([iNth, calls[iNth]]);\n\n    if (iNth + 1 < length) {\n      indexedCalls.push([iNth + 1, calls[iNth + 1]]);\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"n: \".concat(nth, \"\\n\") + \"Expected: not \".concat(printExpectedArgs(expected), \"\\n\") + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1, iNth)) + \"\\nNumber of calls: \".concat((0, _jestMatcherUtils.printReceived)(calls.length));\n  } : () => {\n    // Display preceding and following calls:\n    // * nearest call that is equal to expected args\n    // * otherwise, adjacent call\n    // in case assertions fails because of index, especially off by one.\n    const indexedCalls = [];\n\n    if (iNth < length) {\n      if (iNth - 1 >= 0) {\n        let i = iNth - 1; // Is there a preceding call that is equal to expected args?\n\n        while (i >= 0 && !isEqualCall(expected, calls[i])) {\n          i -= 1;\n        }\n\n        if (i < 0) {\n          i = iNth - 1; // otherwise, adjacent call\n        }\n\n        indexedCalls.push([i, calls[i]]);\n      }\n\n      indexedCalls.push([iNth, calls[iNth]]);\n\n      if (iNth + 1 < length) {\n        let i = iNth + 1; // Is there a following call that is equal to expected args?\n\n        while (i < length && !isEqualCall(expected, calls[i])) {\n          i += 1;\n        }\n\n        if (i >= length) {\n          i = iNth + 1; // otherwise, adjacent call\n        }\n\n        indexedCalls.push([i, calls[i]]);\n      }\n    } else if (length > 0) {\n      // The number of received calls is fewer than the expected number.\n      let i = length - 1; // Is there a call that is equal to expected args?\n\n      while (i >= 0 && !isEqualCall(expected, calls[i])) {\n        i -= 1;\n      }\n\n      if (i < 0) {\n        i = length - 1; // otherwise, last call\n      }\n\n      indexedCalls.push([i, calls[i]]);\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"n: \".concat(nth, \"\\n\") + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(this.expand), calls.length === 1, iNth) + \"\\nNumber of calls: \".concat((0, _jestMatcherUtils.printReceived)(calls.length));\n  };\n  return {\n    message,\n    pass\n  };\n};\n\nconst createNthReturnedWithMatcher = matcherName => function (received, nth, expected) {\n  const expectedArgument = 'n';\n  const options = {\n    expectedColor: arg => arg,\n    isNot: this.isNot,\n    promise: this.promise,\n    secondArgument: 'expected'\n  };\n  ensureMock(received, matcherName, expectedArgument, options);\n\n  if (!Number.isSafeInteger(nth) || nth < 1) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), \"\".concat(expectedArgument, \" must be a positive integer\"), (0, _jestMatcherUtils.printWithType)(expectedArgument, nth, _jestMatcherUtils.stringify)));\n  }\n\n  const receivedName = received.getMockName();\n  const _received$mock3 = received.mock,\n        calls = _received$mock3.calls,\n        results = _received$mock3.results;\n  const length = results.length;\n  const iNth = nth - 1;\n  const pass = iNth < length && isEqualReturn(expected, results[iNth]);\n  const message = pass ? () => {\n    // Display preceding and following results,\n    // in case assertions fails because index is off by one.\n    const indexedResults = [];\n\n    if (iNth - 1 >= 0) {\n      indexedResults.push([iNth - 1, results[iNth - 1]]);\n    }\n\n    indexedResults.push([iNth, results[iNth]]);\n\n    if (iNth + 1 < length) {\n      indexedResults.push([iNth + 1, results[iNth + 1]]);\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"n: \".concat(nth, \"\\n\") + \"Expected: not \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + (results.length === 1 && results[0].type === 'return' && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedResults('Received:     ', expected, indexedResults, results.length === 1, iNth)) + printNumberOfReturns(countReturns(results), calls.length);\n  } : () => {\n    // Display preceding and following results:\n    // * nearest result that is equal to expected value\n    // * otherwise, adjacent result\n    // in case assertions fails because of index, especially off by one.\n    const indexedResults = [];\n\n    if (iNth < length) {\n      if (iNth - 1 >= 0) {\n        let i = iNth - 1; // Is there a preceding result that is equal to expected value?\n\n        while (i >= 0 && !isEqualReturn(expected, results[i])) {\n          i -= 1;\n        }\n\n        if (i < 0) {\n          i = iNth - 1; // otherwise, adjacent result\n        }\n\n        indexedResults.push([i, results[i]]);\n      }\n\n      indexedResults.push([iNth, results[iNth]]);\n\n      if (iNth + 1 < length) {\n        let i = iNth + 1; // Is there a following result that is equal to expected value?\n\n        while (i < length && !isEqualReturn(expected, results[i])) {\n          i += 1;\n        }\n\n        if (i >= length) {\n          i = iNth + 1; // otherwise, adjacent result\n        }\n\n        indexedResults.push([i, results[i]]);\n      }\n    } else if (length > 0) {\n      // The number of received calls is fewer than the expected number.\n      let i = length - 1; // Is there a result that is equal to expected value?\n\n      while (i >= 0 && !isEqualReturn(expected, results[i])) {\n        i -= 1;\n      }\n\n      if (i < 0) {\n        i = length - 1; // otherwise, last result\n      }\n\n      indexedResults.push([i, results[i]]);\n    }\n\n    return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"n: \".concat(nth, \"\\n\") + \"Expected: \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + printReceivedResults('Received: ', expected, indexedResults, results.length === 1, iNth) + printNumberOfReturns(countReturns(results), calls.length);\n  };\n  return {\n    message,\n    pass\n  };\n};\n\nconst spyMatchers = {\n  lastCalledWith: createLastCalledWithMatcher('lastCalledWith'),\n  lastReturnedWith: createLastReturnedMatcher('lastReturnedWith'),\n  nthCalledWith: createNthCalledWithMatcher('nthCalledWith'),\n  nthReturnedWith: createNthReturnedWithMatcher('nthReturnedWith'),\n  toBeCalled: createToBeCalledMatcher('toBeCalled'),\n  toBeCalledTimes: createToBeCalledTimesMatcher('toBeCalledTimes'),\n  toBeCalledWith: createToBeCalledWithMatcher('toBeCalledWith'),\n  toHaveBeenCalled: createToBeCalledMatcher('toHaveBeenCalled'),\n  toHaveBeenCalledTimes: createToBeCalledTimesMatcher('toHaveBeenCalledTimes'),\n  toHaveBeenCalledWith: createToBeCalledWithMatcher('toHaveBeenCalledWith'),\n  toHaveBeenLastCalledWith: createLastCalledWithMatcher('toHaveBeenLastCalledWith'),\n  toHaveBeenNthCalledWith: createNthCalledWithMatcher('toHaveBeenNthCalledWith'),\n  toHaveLastReturnedWith: createLastReturnedMatcher('toHaveLastReturnedWith'),\n  toHaveNthReturnedWith: createNthReturnedWithMatcher('toHaveNthReturnedWith'),\n  toHaveReturned: createToReturnMatcher('toHaveReturned'),\n  toHaveReturnedTimes: createToReturnTimesMatcher('toHaveReturnedTimes'),\n  toHaveReturnedWith: createToReturnWithMatcher('toHaveReturnedWith'),\n  toReturn: createToReturnMatcher('toReturn'),\n  toReturnTimes: createToReturnTimesMatcher('toReturnTimes'),\n  toReturnWith: createToReturnWithMatcher('toReturnWith')\n};\n\nconst isMock = received => received != null && received._isMockFunction === true;\n\nconst isSpy = received => received != null && received.calls != null && typeof received.calls.all === 'function' && typeof received.calls.count === 'function';\n\nconst ensureMockOrSpy = (received, matcherName, expectedArgument, options) => {\n  if (!isMock(received) && !isSpy(received)) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), \" value must be a mock or spy function\"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n  }\n};\n\nconst ensureMock = (received, matcherName, expectedArgument, options) => {\n  if (!isMock(received)) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), \" value must be a mock function\"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n  }\n};\n\nvar _default = spyMatchers;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = exports.createMatcher = void 0;\n\nvar _jestMessageUtil = require('jest-message-util');\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _print = require('./print');\n\nvar _utils = require('./utils');\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\nconst DID_NOT_THROW = 'Received function did not throw';\n\nconst getThrown = e => {\n  const hasMessage = e !== null && e !== undefined && typeof e.message === 'string';\n\n  if (hasMessage && typeof e.name === 'string' && typeof e.stack === 'string') {\n    return {\n      hasMessage,\n      isError: true,\n      message: e.message,\n      value: e\n    };\n  }\n\n  return {\n    hasMessage,\n    isError: false,\n    message: hasMessage ? e.message : String(e),\n    value: e\n  };\n};\n\nconst createMatcher = (matcherName, fromPromise // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n) => function (received, expected) {\n  const options = {\n    isNot: this.isNot,\n    promise: this.promise\n  };\n  let thrown = null;\n\n  if (fromPromise && (0, _utils.isError)(received)) {\n    thrown = getThrown(received);\n  } else {\n    if (typeof received !== 'function') {\n      if (!fromPromise) {\n        const placeholder = expected === undefined ? '' : 'expected';\n        throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, placeholder, options), \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), \" value must be a function\"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n      }\n    } else {\n      try {\n        received();\n      } catch (e) {\n        thrown = getThrown(e);\n      }\n    }\n  }\n\n  if (expected === undefined) {\n    return toThrow(matcherName, options, thrown);\n  } else if (typeof expected === 'function') {\n    return toThrowExpectedClass(matcherName, options, thrown, expected);\n  } else if (typeof expected === 'string') {\n    return toThrowExpectedString(matcherName, options, thrown, expected);\n  } else if (expected !== null && typeof expected.test === 'function') {\n    return toThrowExpectedRegExp(matcherName, options, thrown, expected);\n  } else if (expected !== null && typeof expected.asymmetricMatch === 'function') {\n    return toThrowExpectedAsymmetric(matcherName, options, thrown, expected);\n  } else if (expected !== null && typeof expected === 'object') {\n    return toThrowExpectedObject(matcherName, options, thrown, expected);\n  } else {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), \"\".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('expected'), \" value must be a string or regular expression or class or error\"), (0, _jestMatcherUtils.printWithType)('Expected', expected, _jestMatcherUtils.printExpected)));\n  }\n};\n\nexports.createMatcher = createMatcher;\nconst matchers = {\n  toThrow: createMatcher('toThrow'),\n  toThrowError: createMatcher('toThrowError')\n};\n\nconst toThrowExpectedRegExp = (matcherName, options, thrown, expected) => {\n  const pass = thrown !== null && expected.test(thrown.message);\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + formatExpected('Expected pattern: not ', expected) + (thrown !== null && thrown.hasMessage ? formatReceived('Received message:     ', thrown, 'message', expected) + formatStack(thrown) : formatReceived('Received value:       ', thrown, 'value')) : () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + formatExpected('Expected pattern: ', expected) + (thrown === null ? '\\n' + DID_NOT_THROW : thrown.hasMessage ? formatReceived('Received message: ', thrown, 'message') + formatStack(thrown) : formatReceived('Received value:   ', thrown, 'value'));\n  return {\n    message,\n    pass\n  };\n};\n\nconst toThrowExpectedAsymmetric = (matcherName, options, thrown, expected) => {\n  const pass = thrown !== null && expected.asymmetricMatch(thrown.value);\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + formatExpected('Expected asymmetric matcher: not ', expected) + '\\n' + (thrown !== null && thrown.hasMessage ? formatReceived('Received name:    ', thrown, 'name') + formatReceived('Received message: ', thrown, 'message') + formatStack(thrown) : formatReceived('Thrown value: ', thrown, 'value')) : () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + formatExpected('Expected asymmetric matcher: ', expected) + '\\n' + (thrown === null ? DID_NOT_THROW : thrown.hasMessage ? formatReceived('Received name:    ', thrown, 'name') + formatReceived('Received message: ', thrown, 'message') + formatStack(thrown) : formatReceived('Thrown value: ', thrown, 'value'));\n  return {\n    message,\n    pass\n  };\n};\n\nconst toThrowExpectedObject = (matcherName, options, thrown, expected) => {\n  const pass = thrown !== null && thrown.message === expected.message;\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + formatExpected('Expected message: not ', expected.message) + (thrown !== null && thrown.hasMessage ? formatStack(thrown) : formatReceived('Received value:       ', thrown, 'value')) : () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + (thrown === null ? formatExpected('Expected message: ', expected.message) + '\\n' + DID_NOT_THROW : thrown.hasMessage ? (0, _jestMatcherUtils.printDiffOrStringify)(expected.message, thrown.message, 'Expected message', 'Received message', true) + '\\n' + formatStack(thrown) : formatExpected('Expected message: ', expected.message) + formatReceived('Received value:   ', thrown, 'value'));\n  return {\n    message,\n    pass\n  };\n};\n\nconst toThrowExpectedClass = (matcherName, options, thrown, expected) => {\n  const pass = thrown !== null && thrown.value instanceof expected;\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + (0, _print.printExpectedConstructorNameNot)('Expected constructor', expected) + (thrown !== null && thrown.value != null && typeof thrown.value.constructor === 'function' && thrown.value.constructor !== expected ? (0, _print.printReceivedConstructorNameNot)('Received constructor', thrown.value.constructor, expected) : '') + '\\n' + (thrown !== null && thrown.hasMessage ? formatReceived('Received message: ', thrown, 'message') + formatStack(thrown) : formatReceived('Received value: ', thrown, 'value')) : () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + (0, _print.printExpectedConstructorName)('Expected constructor', expected) + (thrown === null ? '\\n' + DID_NOT_THROW : (thrown.value != null && typeof thrown.value.constructor === 'function' ? (0, _print.printReceivedConstructorName)('Received constructor', thrown.value.constructor) : '') + '\\n' + (thrown.hasMessage ? formatReceived('Received message: ', thrown, 'message') + formatStack(thrown) : formatReceived('Received value: ', thrown, 'value')));\n  return {\n    message,\n    pass\n  };\n};\n\nconst toThrowExpectedString = (matcherName, options, thrown, expected) => {\n  const pass = thrown !== null && thrown.message.includes(expected);\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + formatExpected('Expected substring: not ', expected) + (thrown !== null && thrown.hasMessage ? formatReceived('Received message:       ', thrown, 'message', expected) + formatStack(thrown) : formatReceived('Received value:         ', thrown, 'value')) : () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\\n\\n' + formatExpected('Expected substring: ', expected) + (thrown === null ? '\\n' + DID_NOT_THROW : thrown.hasMessage ? formatReceived('Received message:   ', thrown, 'message') + formatStack(thrown) : formatReceived('Received value:     ', thrown, 'value'));\n  return {\n    message,\n    pass\n  };\n};\n\nconst toThrow = (matcherName, options, thrown) => {\n  const pass = thrown !== null;\n  const message = pass ? () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\\n\\n' + (thrown !== null && thrown.hasMessage ? formatReceived('Error name:    ', thrown, 'name') + formatReceived('Error message: ', thrown, 'message') + formatStack(thrown) : formatReceived('Thrown value: ', thrown, 'value')) : () => (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\\n\\n' + DID_NOT_THROW;\n  return {\n    message,\n    pass\n  };\n};\n\nconst formatExpected = (label, expected) => label + (0, _jestMatcherUtils.printExpected)(expected) + '\\n';\n\nconst formatReceived = (label, thrown, key, expected) => {\n  if (thrown === null) {\n    return '';\n  }\n\n  if (key === 'message') {\n    const message = thrown.message;\n\n    if (typeof expected === 'string') {\n      const index = message.indexOf(expected);\n\n      if (index !== -1) {\n        return label + (0, _print.printReceivedStringContainExpectedSubstring)(message, index, expected.length) + '\\n';\n      }\n    } else if (expected instanceof RegExp) {\n      return label + (0, _print.printReceivedStringContainExpectedResult)(message, typeof expected.exec === 'function' ? expected.exec(message) : null) + '\\n';\n    }\n\n    return label + (0, _jestMatcherUtils.printReceived)(message) + '\\n';\n  }\n\n  if (key === 'name') {\n    return thrown.isError ? label + (0, _jestMatcherUtils.printReceived)(thrown.value.name) + '\\n' : '';\n  }\n\n  if (key === 'value') {\n    return thrown.isError ? '' : label + (0, _jestMatcherUtils.printReceived)(thrown.value) + '\\n';\n  }\n\n  return '';\n};\n\nconst formatStack = thrown => thrown === null || !thrown.isError ? '' : (0, _jestMessageUtil.formatStackTrace)((0, _jestMessageUtil.separateMessageFromStack)(thrown.value.stack).stack, {\n  rootDir: process.cwd(),\n  testMatch: []\n}, {\n  noStackTrace: false\n});\n\nvar _default = matchers;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}
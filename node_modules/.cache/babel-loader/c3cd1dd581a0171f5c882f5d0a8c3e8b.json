{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.printReceivedConstructorNameNot = exports.printReceivedConstructorName = exports.printExpectedConstructorNameNot = exports.printExpectedConstructorName = exports.printCloseTo = exports.printReceivedArrayContainExpectedItem = exports.printReceivedStringContainExpectedResult = exports.printReceivedStringContainExpectedSubstring = void 0;\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// Format substring but do not enclose in double quote marks.\n// The replacement is compatible with pretty-format package.\n\n\nconst printSubstring = val => val.replace(/\"|\\\\/g, '\\\\$&');\n\nconst printReceivedStringContainExpectedSubstring = (received, start, length) => (0, _jestMatcherUtils.RECEIVED_COLOR)('\"' + printSubstring(received.slice(0, start)) + (0, _jestMatcherUtils.INVERTED_COLOR)(printSubstring(received.slice(start, start + length))) + printSubstring(received.slice(start + length)) + '\"');\n\nexports.printReceivedStringContainExpectedSubstring = printReceivedStringContainExpectedSubstring;\n\nconst printReceivedStringContainExpectedResult = (received, result) => result === null ? (0, _jestMatcherUtils.printReceived)(received) : printReceivedStringContainExpectedSubstring(received, result.index, result[0].length); // The serialized array is compatible with pretty-format package min option.\n// However, items have default stringify depth (instead of depth - 1)\n// so expected item looks consistent by itself and enclosed in the array.\n\n\nexports.printReceivedStringContainExpectedResult = printReceivedStringContainExpectedResult;\n\nconst printReceivedArrayContainExpectedItem = (received, index) => (0, _jestMatcherUtils.RECEIVED_COLOR)('[' + received.map((item, i) => {\n  const stringified = (0, _jestMatcherUtils.stringify)(item);\n  return i === index ? (0, _jestMatcherUtils.INVERTED_COLOR)(stringified) : stringified;\n}).join(', ') + ']');\n\nexports.printReceivedArrayContainExpectedItem = printReceivedArrayContainExpectedItem;\n\nconst printCloseTo = (receivedDiff, expectedDiff, precision, isNot) => {\n  const receivedDiffString = (0, _jestMatcherUtils.stringify)(receivedDiff);\n  const expectedDiffString = receivedDiffString.includes('e') // toExponential arg is number of digits after the decimal point.\n  ? expectedDiff.toExponential(0) : 0 <= precision && precision < 20 // toFixed arg is number of digits after the decimal point.\n  ? // It may be a value between 0 and 20 inclusive.\n  // Implementations may optionally support a larger range of values.\n  expectedDiff.toFixed(precision + 1) : (0, _jestMatcherUtils.stringify)(expectedDiff);\n  return \"Expected precision:  \".concat(isNot ? '    ' : '', \"  \").concat((0, _jestMatcherUtils.stringify)(precision), \"\\n\") + \"Expected difference: \".concat(isNot ? 'not ' : '', \"< \").concat((0, _jestMatcherUtils.EXPECTED_COLOR)(expectedDiffString), \"\\n\") + \"Received difference: \".concat(isNot ? '    ' : '', \"  \").concat((0, _jestMatcherUtils.RECEIVED_COLOR)(receivedDiffString));\n};\n\nexports.printCloseTo = printCloseTo;\n\nconst printExpectedConstructorName = (label, expected) => printConstructorName(label, expected, false, true) + '\\n';\n\nexports.printExpectedConstructorName = printExpectedConstructorName;\n\nconst printExpectedConstructorNameNot = (label, expected) => printConstructorName(label, expected, true, true) + '\\n';\n\nexports.printExpectedConstructorNameNot = printExpectedConstructorNameNot;\n\nconst printReceivedConstructorName = (label, received) => printConstructorName(label, received, false, false) + '\\n'; // Do not call function if received is equal to expected.\n\n\nexports.printReceivedConstructorName = printReceivedConstructorName;\n\nconst printReceivedConstructorNameNot = (label, received, expected) => typeof expected.name === 'string' && expected.name.length !== 0 && typeof received.name === 'string' && received.name.length !== 0 ? printConstructorName(label, received, true, false) + \" \".concat(Object.getPrototypeOf(received) === expected ? 'extends' : 'extends â€¦ extends', \" \").concat((0, _jestMatcherUtils.EXPECTED_COLOR)(expected.name)) + '\\n' : printConstructorName(label, received, false, false) + '\\n';\n\nexports.printReceivedConstructorNameNot = printReceivedConstructorNameNot;\n\nconst printConstructorName = (label, constructor, isNot, isExpected) => typeof constructor.name !== 'string' ? \"\".concat(label, \" name is not a string\") : constructor.name.length === 0 ? \"\".concat(label, \" name is an empty string\") : \"\".concat(label, \": \").concat(!isNot ? '' : isExpected ? 'not ' : '    ').concat(isExpected ? (0, _jestMatcherUtils.EXPECTED_COLOR)(constructor.name) : (0, _jestMatcherUtils.RECEIVED_COLOR)(constructor.name));","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.diffLinesRaw = exports.diffLinesUnified2 = exports.diffLinesUnified = void 0;\n\nvar _diffSequences = _interopRequireDefault(require('diff-sequences'));\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _normalizeDiffOptions = require('./normalizeDiffOptions');\n\nvar _printDiffs = require('./printDiffs');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst isEmptyString = lines => lines.length === 1 && lines[0].length === 0; // Compare two arrays of strings line-by-line. Format as comparison lines.\n\n\nconst diffLinesUnified = (aLines, bLines, options) => (0, _printDiffs.printDiffLines)(diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines), (0, _normalizeDiffOptions.normalizeDiffOptions)(options)); // Given two pairs of arrays of strings:\n// Compare the pair of comparison arrays line-by-line.\n// Format the corresponding lines in the pair of displayable arrays.\n\n\nexports.diffLinesUnified = diffLinesUnified;\n\nconst diffLinesUnified2 = (aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) => {\n  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {\n    aLinesDisplay = [];\n    aLinesCompare = [];\n  }\n\n  if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {\n    bLinesDisplay = [];\n    bLinesCompare = [];\n  }\n\n  if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) {\n    // Fall back to diff of display lines.\n    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);\n  }\n\n  const diffs = diffLinesRaw(aLinesCompare, bLinesCompare); // Replace comparison lines with displayable lines.\n\n  let aIndex = 0;\n  let bIndex = 0;\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        diff[1] = aLinesDisplay[aIndex];\n        aIndex += 1;\n        break;\n\n      case _cleanupSemantic.DIFF_INSERT:\n        diff[1] = bLinesDisplay[bIndex];\n        bIndex += 1;\n        break;\n\n      default:\n        diff[1] = bLinesDisplay[bIndex];\n        aIndex += 1;\n        bIndex += 1;\n    }\n  });\n  return (0, _printDiffs.printDiffLines)(diffs, (0, _normalizeDiffOptions.normalizeDiffOptions)(options));\n}; // Compare two arrays of strings line-by-line.\n\n\nexports.diffLinesUnified2 = diffLinesUnified2;\n\nconst diffLinesRaw = (aLines, bLines) => {\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  const diffs = [];\n  let aIndex = 0;\n  let bIndex = 0;\n\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex]));\n    }\n\n    for (; bIndex !== bCommon; bIndex += 1) {\n      diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex]));\n    }\n\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_EQUAL, bLines[bIndex]));\n    }\n  };\n\n  (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence); // After the last common subsequence, push remaining change items.\n\n  for (; aIndex !== aLength; aIndex += 1) {\n    diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex]));\n  }\n\n  for (; bIndex !== bLength; bIndex += 1) {\n    diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex]));\n  }\n\n  return diffs;\n};\n\nexports.diffLinesRaw = diffLinesRaw;","map":null,"metadata":{},"sourceType":"script"}